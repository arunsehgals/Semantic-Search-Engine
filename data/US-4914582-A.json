or such machines, the cache memory produces a very substantial increase in execution speed. However, the performance of the computer system is still limited in instruction execution rate by cache memory access time. Additional increases in instruction execution rate can be gained by further decreasing the cache memory access time.</p><p>The success of cache memories is based on the assumption that, because a particular memory location has been referenced, that location and locations very close to it are very likely to be accessed in the near future. This is often referred to as the property of locality. The property of locality has two aspects, temporal and spatial. While over short periods of time, a program distributes its memory references nonuniformly over its address space, the portions of the address space which are favored remain largely the same for long periods of time. This first property of locality, called temporal locality, or locality by time, means that the information which will be in use in the near future is likely to be in use already. This type of behavior can be expected from program loops in which both data and instructions are reused. The second property of locality, locality by space, means that portions of the address space which are in use generally consist of a fairly small number of individually contiguous segments of that address space. Locality by space, then, means that the loci of reference of the program in the near future are likely to be near the current loci of reference. This type of behavior can be expected from common knowledge of programs: related data items (variables, arrays) are usually stored together, and instructions are mostly executed sequentially. Since the cache memory buffers segments of information that have been recently used, the property of locality implies that needed information is also likely to be found in the cache. See, Smith, A. J., Cache Memories, ACM Computing Surveys, 14:3 (Sept. 1982), pp 473-530.</p><p>A cache is made up of many blocks of one or more words of data, each of which has associated with it an address tag that uniquely identifies which block of main memory it is a copy of. Each time the processor makes a memory reference, the cache makes an address tag comparison to see if it has a copy of the requested data. If it does, it supplies the data; if it does not, it retrieves the block from main memory, replacing one of the blocks stored in the cache, and then supplies the retrieved data to the processor.</p><p>Optimizing the design of a cache memory generally has four aspects:</p><p>(1) Maximizing the probability of finding a memory reference's information in the cache (the so-called \"hit\" ratio),</p><p>(2) minimizing the time required to access information that is indeed in the cache (access time),</p><p>(3) minimizing the delay due to a cache \"miss\", and</p><p>(4) minimizing the overheads of updating main memory and maintaining multicache consistency.</p><p>All of these objectives must be accomplished under suitable cost constraints and in view of the interrelationship between the parameters; for example, the trade-off between hit ratio and access time. It is obvious that the larger the cache, the higher the probability of finding the needed information in it. Cache sizes cannot be expanded without limit, however, for several reasons: cost, the most important reason in many machines, especially small ones; physical size, the cache must fit on the boards and in the cabinets; and access time, the larger the cache, the slower it will become.</p><p>Information is generally retrieved from cache associatively to determine if there is a \"hit\". However, large, fully associative memories are both very expensive and somewhat slow. In early cache memories, all the elements were searched associatively for each request by the CPU. In order to provide the access time required to keep up with the CPU, cache size was limited and the hit ratio was thus rather low.</p><p>FIG. 1 is a schematic illustration of a conventional, direct-map single-set cache. As described above, the illustrated cache comprises a number of blocks, each with its own data and address tag. For any cache access, a portion of the address, called the index, is used to select one block (in an operation like a RAM access) which will be checked to see if it is the one requested. If it is not the requested block, then the cache will fetch the correct one from main memory, replacing the block it checked. Thus, for any block in main memory, there is exactly one block in the cache that may contain it. The cache illustrated in FIG. 1 has four words of data in each block. Because the location in the cache uniquely specifies the index portion of the address, the tag compare need only be done on the higher portion of the address.</p><p>Cache memories may also be organized into groups of smaller associative memories called sets, each containing a number of locations, referred to as the set size. For a cache of size m, divided into L sets, there are s=m/L locations in each set. When an address in main memory is mapped into the cache, it can appear in any of the L sets. For a cache of a given size, searching each of the sets in parallel can improve access time by a factor of L.</p><p>FIG. 2 is a schematic illustration of the simplest and most common associative multi-set cache, the two-set cache. In an n-set cache, each block of memory has \"n\" possible slots in which it might be stored in the cache; so a process could have \"n\" blocks with the same index in the cache simultaneously without \"thrashing\". The cache accesses each of the \"n\" blocks at the specified index simultaneously and checks to see if any is the requested block. If one is, the cache returns it; if it is not, it fetches the requested block from main memory replacing one of the blocks with the new one. In a cache with more than two sets, the extra sets are added in parallel, with the final level of OR-ing and multiplexing getting wider.</p><p>The design choice between the single-set, direct-map cache shown in FIG. 1 and an associative, multi-set cache of the type shown in FIG. 2 is based on a trade-off between access time and hit ratio. For the same size cache, the access time for a multi-set cache is longer than for a single-set cache because the associative address comparison and required multiplexing can take a long time. The multi-set cache is also more expensive. On the other hand, the hit ratio of the multi-set cache is better.</p><p>Obviously, it would be advantageous to improve the access time for a multi-set cache.</p><h4>SUMMARY</h4><p>It is an object of the present invention to reduce the time to access a multi-set cache memory.</p><p>This and other objects of the invention are accomplished by utilizing a standard address tag comparison to check for a cache hit, plus a comparison of a second, smaller set of \"lookaside tags\" which are used only for set selection. Since the \"lookaside tags\"  are smaller, the comparison, and hence the set selection, can be performed faster than in prior art multi-set cache operations.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a schematic illustration of a conventional single-set cache;</p><p>FIG. 2 is a schematic illustration of a conventional multiple-set cache;</p><p>FIG. 3 is a schematic block diagram of a computer system having a cache memory;</p><p>FIG. 4 is a schematic illustration of the structure of a cache memory in accordance with the present invention;</p><p>FIG. 5 is a schematic block diagram illustrating the operation of a cache memory according to the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>A computer system which includes a cache memory is illustrated in FIG. 3. A CPU 11 communicates with main memory 13 and an input/output channel 15 via bus 17. The CPU includes a processor 19 which fetches, decodes and executes instructions to process data. Since it is not practical to store all the instructions and data used by the computer system in CPU 11, the data and instructions are stored in main memory 13, transferred to processor 19 when they are requested during the execution of a program or routine and returned to main memory after the program or routine has been completed.</p><p>Access to main memory 13 is relatively slow compared with the operation of processor 19. If processor 19 had to wait for main memory access to be completed each time an instruction or data was needed, its execution rate would be significantly reduced. In order to provide access times which more closely match the needs of the processor 19, a buffer memory, cache memory 21, stores a limited number of instructions and data. Since cache 21 is much smaller than main memory 13 it can be economically built to have higher access rates.</p><p>Nevertheless, there is still a trade-off between the access time for the cache memory 21 and the size of the cache. As discussed above, as the cache becomes larger and more complex, it becomes more expensive and its access time increases. Thus, if cache 21 is made very large to increase the hit ratio, although there are very few references to main memory 13, the processor 19 may be slowed down by increased access time even for a \"hit.\" It is therefore desirable to decrease the cache memory access time as much as possible.</p><p>To explain the present invention more completely an understanding of the structure of cache 21 is necessary. FIG. 4 shows a cache memory having two sets A and B. Each set comprises an array of locations or blocks which are labeled with an index 23. Each block contains data 25 and an address tag 27. In addition to the normal address tag 27, a smaller, \"lookaside tag\" 29 derived from the standard address tag is also designated. The \"lookaside tag\" is an arbitrary number of bits long, but it is less than that necessary to check for a hit.</p><p>In the preferred embodiment, each data block contains four words. The four-word unit is the unit in which data is exchanged between cache memory 21 and main memory 13 and is also the unit in which data is indexed, fetched and replaced in the cache 21. A block could contain fewer or more words, (but always a power of 2. These parameters are a matter of design choice for the memory system.</p><p>Each time processor 19 makes a memory reference, cache 21 is searched to see if it has a copy of the requested data. If it does, the data is supplied to the processor 19. Otherwise, the data must be fetched in a block from main memory 13, supplied to the processor 19 and stored in cache memory 21, replacing one of the blocks already in the cache in accordance with a replacement scheme.</p><p>The most commonly used and preferred replacement scheme is Least Recently Used (\"LRU\"). According to the LRU replacement scheme, for each group of blocks at a particular index, the cache maintains several status bits that keep track of the order in which these blocks were last accessed. Each time one of the blocks is accessed, it is marked most recently used and the others are adjusted accordingly. When there is a miss, the block swapped out to make room for the block being retrieved from main memory is the block that was least recently used.</p><p>FIG. 5 illustrates the cache search operation of the present invention utilizing the \"lookaside tags\". A search of the cache commences when processor 19 presents an address to be retrieved. The address comprises an address tag which identifies the location of the requested data in main memory and an index. The index is provided to the cache which responds by returning the blocks in each cache set A and B corresponding to the index. The \"lookaside tag\" for the returned block from one of sets A and B is then compared with the corresponding part of the address. If there is a match, then that set is selected for immediate return to the processor; otherwise, the remaining set is provided to the processor. The normal full tag comparison is utilized in parallel to confirm a \"hit.\"</p><p>If the full tag comparison determines that there is, in fact, a \"miss,\" then since the processor has retrieved but not yet executed the erroneous data provided by the \"lookaside tag\" comparison, the required data can be fetched from main memory and provided to the processor in a timely manner.</p><p>While the \"lookaside tag\" procedure has been described in conjunction with a two-set cache, it should be appreciated that the procedure is applicable to multi-set caches of any set size.</p><p>A problem an arise if there are two blocks in the cache that have the same \"lookaside tag\" but diffe