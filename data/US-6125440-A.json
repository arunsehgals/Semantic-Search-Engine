ions are being executed, the circuitry changes state and it is during these transitions that substantial power is consumed. Because power is consumed mainly during transitions, it follows that when higher operating speeds are employed the transitions become both more frequent and a larger percentage of the total time and so the total power consumption increases in direct relationship to operating frequency. One of the most power consuming portions of a digital processor is the RAM in which micro-code instructions and data are stored. The highest power consumption in this RAM occurs when information is being read into the memory or is being read out of the memory.</p><p>Under certain conditions, however, the processor is merely awaiting the occurrence of an event such as the entry of a key stroke, the arrival of data from another source, an interrupt signal, a frame pulse, a channel pulse, or some other event of frequency and timing which are uncertain. In that condition, the digital processor will continue to operate at normal speed, consuming full power, when no useful processing or data manipulation is being accomplished. Digital processor power would be substantially reduced if the accessing of the instruction memory (RAM) is minimized or eliminated during these times of waiting.</p><p>One of the most common techniques to do this is to stop the operation of the entire digital processor or to stop parts of its circuitry when no operation is required, for example, by switching off the power to the circuit or by stopping the clock. But this requires either an interrupt signal or a reset signal in order to resume operation, which is undesirable because of the processing overhead necessary to accomplish the restoration of operation and/or the need for special instructions to accomplish that restoration.</p><p>U.S. Pat. No. 5,579,493 entitled \"System With Loop Buffer and Repeat Control Circuit Having Stack for Storing Control Information\" issued to Kiuchi et al. describes a low power data processor which includes an instruction buffer for storing an instruction module, i.e. a set of instructions to be repeatedly executed, in place of accessing the instruction memory (RAM) to fetch that instruction module on a repetitive basis. Kiuchi et al. requires, however, that a special instruction follow each instruction module that is to be repeatedly executed. This special instruction specifies the predetermined number of times that the system is to branch to the head (starting) address of the instruction module to be repeatedly executed. Because the special instruction of Kiuchi et al. follows the instruction module, the module is read out from the RAM in its first repetition and is then again read out from the instruction memory in its second execution during which it is written into an instruction buffer. On subsequent repetitions, it is read out from the instruction buffer. As a result, the power reduction due to avoidance of accessing the instruction memory cannot be realized until the third repetition of each particular instruction module.</p><p>European Patent Application EP 0 511 484 A2 entitled \"Loop Control In A Data Processor\" issued to Okado et al. is a data processor including an instruction decoder for decoding a specific repeat instruction which is read from the read only memory (ROM) to cause the specific instructions following the repeat instruction to be executed repeatedly. The repeat controller reads these instructions in series from the micro ROM and places them into instruction registers for subsequent repeated execution. Okado et al. requires a special repeat instruction that precedes each group of instructions that are to be executed repeatedly. The special repeat instruction of Okado et al. specifies the number of steps or instructions that are to be repeatedly executed and the predetermined number of times the subsequent instructions are to be repeated.</p><p>Both Kiuchi et al. and Okado et al. require a special instruction which defines the instructions to be repeatedly executed. As a result, if the programmer or operator forgets the special instruction or improperly inputs data into it, the data processor will not work properly and/or the intended power savings will not be realized. This is further complicated by requiring that upon making a program change, the programmer must not only change the executable instruction, but must also change the special repeat instruction if proper operation and the attendant reduction of power consumption is to be realized.</p><p>Accordingly, it is desirable that an arrangement for reduction of power consumption in a digital processor by reducing the power consumption of its memory be available, and that it operate directly from the execution instructions of the program code rather than from a special instruction defining the loop to be repeatedly executed. It is further desirable that this arrangement be able to accommodate multiple loops within the code as well as nested loops without requiring overhead processing and without any special programming instruction.</p><p>A digital processor control according to the present invention comprises a memory adapted to store instructions to be executed where such instructions may include at least one sequence of instructions that are to be executed more than one time. The memory produces ones of the stored instructions in accordance with a first control signal. A register is coupled to the memory to store a sequence of instructions produced by the memory and is responsive to a second control signal to produce ones of the sequence of instructions stored in the register. A control device detects ones of the instructions produced by the memory and the register that initiate repetition of the sequence of instructions that are to be executed more than one time. A state machine responds to the control device to generate the first control signal when instructions to be executed more than one time are not detected and to generate the second control signal when the instructions to be executed more than one time are detected.</p><p>A digital controller comprises an addressable memory to produce instructions when enabled and a shift register to store instructions produced by the addressable memory and to produce the stored instructions when enabled. A controller decodes executable instructions produced by the addressable memory and the shift register, wherein the decoded instructions include jump-back instructions and jump-forward instructions. An instruction address and a target address is associated with each jump-back and jump-forward instruction. A memory control has a mapping state in which the shift register is enabled and a non-mapping state in which the addressable memory is enabled. The memory control is responsive to the controller to take the mapping state when a jump-back instruction is decoded and to take the non-mapping state when a jump-forward instruction is decoded.</p><p>A method for reducing power consumption in a digital processor comprises the steps of:</p><p>producing from a memory a sequence of executable instructions to be executed, including a shorter sequence of executable instructions to be repetitively executed;</p><p>storing in a register the shorter sequence of executable instructions to be repetitively executed;</p><p>decoding ones of the sequence of executable instructions that are jump-back instructions;</p><p>disabling in response to decoding of the jump-back instruction the memory from producing further instructions in the sequence of executable instructions; and</p><p>producing in response to the decoding of the jump-back instruction from the register and executing ones of the shorter sequence of executable instructions stored therein.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWING</h4><p>In the Drawing:</p><p>FIG. 1 is a schematic block diagram of a controller for a digital processor including an embodiment according to the present invention;</p><p>FIG. 2 is a logic flow diagram of a loop;</p><p>FIG. 3 is a schematic block diagram of an embodiment of a memory control useful with the embodiment of FIG. 1; and</p><p>FIG. 4 is a state diagram showing the operation of a portion of the embodiment of FIG. 3.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><p>In the Drawing, paths for digital signals having one bit are generally shown as single line arrows and paths for digital signals including multiple bits in parallel are generally shown as broad arrows, however, serial information, serial bits and words may be transmitted over a path shown by either a single line arrow or a broad arrow. The following instructions and abbreviations are used in the description herein.</p><p>\"JMP-\" means an instruction to \"jump\" backward from the present instruction to an instruction prior in the sequence of instructions to be executed, i.e. an instruction having a lower address number.</p><p>\"JMP+\" means an instruction to \"jump\" forward from the present instruction to an instruction that is later in the sequence of instructions to be executed, i.e. an instruction having a higher address number.</p><p>\"ADDR\" means an address of an instruction to be executed.</p><p>\"JMP<sub>--</sub> ADDR\" means the address in a jump instruction (JMP+ or JMP-) specifying the address to which the instruction sequence should next go to. This is sometime referred to as a \"target address\".</p><p>MEM<sub>--</sub> ADDR means a memory access signal specifying the address of a register in the memory from which information stored therein is to be read out or fetched when the memory is enabled.</p><p>MEM<sub>--</sub> EN means a memory enable signal which when present enables the memory to be accessed and data stored in the registers thereof to be produced at an output or fetched in accordance with a memory address signal.</p><p>SH<sub>--</sub> EN means a shift enable signal which when present enables a shift register to store in its registers (shift in) the information present at its data input.</p><p>CE1 means a chip enable signal which when present enables a shift register to produce at its output (or fetch) data stored in a particular stage of that shift register having an address corresponding to a shift register address signal.</p><p>SRB<sub>--</sub> ADDR means a shift register address signal specifying the stage of the shift register from which information is to be produced at the output of the shift register (or fetched) when the shift register is enabled.</p><p>CN<sub>--</sub> EN means a counter enable signal which enables a counter to count signals received at its input.</p><p>CN<sub>--</sub> RST means a counter reset signal which causes the count stored in a counter to become a predetermined number, usually zero unless specified otherwise.</p><p>LD<sub>--</sub> EN means a load enable signal which enables a register to accept and store or load the information present at its data input.</p><p>COMP means a comparator. In the drawing, a comparator has a \"greater than\" (&gt;) or \"greater than or equal\" (\u2267) symbol or a \"less than\" (&lt;) or \"less than or equal\" (&lt;) symbol which indicates that when the function of the comparator is written out as an equation, the data present at the upper most input of the comparator appears in the left side of the equation separated from the data present at the lower most input, which appears in the right side of the equation and those two quantities are separated by the symbol contained within the box designating the comparator.</p><p>In FIG. 1, controller 10 for a digital processor includes a Random Access Memory (RAM) 12 in which executable instructions are stored, which instructions may be fetched into an Instruction Register (IR) 14 and decoded by control 16 for controlling the execution of such instructions. The instructions decoded by control 16 are sent via a data bus to the execution unit or arithmetic logic unit ALU 17 for execution. Instructions decoded by control 16 are further sent to the Memory Management Unit (MMU) 20 for controlling RAM 12. As thus far described, processor 10 retrieves all instructions to be executed from RAM 12, even where instructions are repetitively executed or where the processor is merely awaiting for an event or data input. Data is communicated to or from processor 10 via input/output (I/O) bus 30 and is communicated within processor 10 via input/output (I/O) unit 32 and data bus 31.</p><p>The sequence of instructions to be executed by the digital processor, commonly referred to as a program, is a series of micro-code instructions that are stored in the random access memory 12. Prior to operation of the processor, the instructions are passed into the controller via the I/O bus 30 through the I/O unit 32 and are directed then through the memory management unit 20 and into random access memory 12 where they are stored until called upon for execution, as is conventional. To avoid clutter in the accompanying drawing and to preserve clarity with regard to the present invention, the control signals and signal paths employed solely in loading programs and micro-code into RAM 12 are not shown.</p><p>FIG. 2 is a flow diagram of a processing loop known variously as a \"tight loop\" or as a \"wait loop\". In the condition represented by block 102 Receive Input Data, the processor is waiting for a particular piece of information or signal to arrive. It periodically compares the data it last received to a mask or template represented by block 104 and executes the decision shown in the block 106, Match? If the input data received does not match that of the mask, the loop proceeds along the \"No\" path 108 and repeats the cycle. The cycle continues to be repeated until the input data received does match that of the mask 104 in which case the comparison function 106 yields a true result and the flow proceeds along the \"Yes\" path 110 to proceed with further processing. While this type of loop might be intended to be performed a particular number of times or might be intended to be performed for a particular period of time, it is also common that the loop is to await a particular event, such as a key stroke from an input device, receipt of an external signal, an interrupt signal, a frame pulse, a channel pulse, or some particular piece of data to arrive from another part of the processor or from the equipment of which the processor is a part. As can be seen from FIG. 2 and the foregoing description, a loop is characterized by the lack of a match between the received input data and that of the mask which causes the processor to \"jump\" to an earlier instruction 102 in the sequence of instructions that the processor is executing. Accordingly, this \"jump\" is indicative of a processing loop, i.e. a sequence of instructions that are repeatedly executed.</p><p>The digital processor of FIG. 1 also includes a Shift Register Bank (SRB) 24 into which the instructions fetched from RAM 12 are also inputted or stored under conditions to be described below. SRB 24 has a word length selected to be the same as the length of the words retrieved from the RAM 12 and has a \"depth\", i.e. the number of words in its storage capacity, that is selected in relation to the number of steps expected to be in a loop. While one cannot always be certain as to how many steps will be in any particular loop, an experienced designer of ordinary skill will understand that a range of numbers of instruction words will be encountered and will select the depth of SRB 24 accordingly. In a typical processor, a depth of between 5 and 10 instruction words (i.e., shift register stages) is often adequate, however, a greater depth of perhaps 15 to 20 words may be equally convenient. It is understood that a greater depth of SRB 24 may be employed in a controller for a general purpose processor or microprocessor where there may be less certainty of the number of instructions in the largest loop and that a lesser depth may be employed in a special purpose processor such as a digital signal processor where the number of instructions in the loops may be known with greater certainty.</p><p>Shift Register Bank (SRB) 24 is controlled by signals from memory management unit (MMU) 20. In particular, a shift enable signal SH<sub>--</sub> EN enables SRB 24 to receive data word inputs from RAM 12 and to shift those data words into its register banks. Each data word shifted into SRB 24 is shifted into the first or input stage registers thereof, and then to the second stage registers thereof when a subsequent data word is shifted into the first stage, and then to subsequent or \"deeper\" stage registers and so forth until they reach the last or N-th stage registers, i.e. the stage most remote from the first or input stage. As each additional data word is shifted into shift register bank 24, the data stored in the N-th stage thereof is shifted out and is lost. Enable Signal CE1 enables SRB 24 to produce as its output that data word stored in the stage of shift register 24 corresponding to the shift register read out address SRB<sub>--</sub> ADDR provided from MMU 20.</p><p>MMU 20 further provides a memory enable signal MEM<sub>--</sub> EN that enables RAM 12 to produce at its output those instructions (data words) stored in its memory register having an address corresponding to that specified by the memory address signal MEM<sub>--</sub> ADDR also provided by MMU 20. Memory Management Unit 20 includes inter alia a state tracking machine (STM) 210 responsive to indications that control 16 has decoded certain jump commands, in particular, a \"JMP+\" command, a \"JMP-\" command and the target address JMP<sub>--</sub> ADDR to which the aforementioned jump commands direct the processor.</p><p>In operation of the processor of FIG. 1, RAM 12 is enabled by memory enable signal MEM<sub>--</sub> EN and MMU 20 generates a sequence of memory address signals MEM<sub>--</sub> ADDR, typically a series of numbers in ascending sequence, which causes RAM 12 to fetch to instruction register 14 the sequence of instructions corresponding to that sequence of memory addresses. MMU 20 also generates the shift enable signal SH<sub>--</sub> EN which enables shift register bank 24 to shift into its registers the instructions produced at the output of RAM 12. On each cycle, another word of instruction data is produced by RAM 12 and is inputted (shifted) into the first stage of SRB 24 as the most recent word in the shift register, and the word previously stored therein is shifted into the second register, that in the second register is shifted into the third register, and then to the next register as the process continues. Accordingly, the SRB 24 will include N words, where N is the depth of the SRB in number of stages, which will contain the data words that correspond to the last N instructions executed by the processor. This operation continues and the digital processor 10 executes instructions produced by PAM 12 until a loop condition is decoded by control 16.</p><p>This condition wherein the digital processor of FIG. 1 is reading or fetching instructions from RAM 12 into instruction register 14 and shift register bank 24 is referred to herein as the \"non-mapping\" mode or \"non-mapping\" state and the condition (described below) wherein instructions to be executed are being fetched from shift register SRB 24 and not from RAM 12 is referred to herein as the \"mapping\" mode or \"mapping\" state.</p><p>As previously mentioned, a loop is indicated from the instructions being executed calling for a jump command JMP- indicating a jump to an instruction having a prior position in the sequence of instructions. The decoding of the JMP- command by control 16 causes MMU 20 to change its output signals before the next instruction is fetched, i.e. to enter the mapping state. Specifically, enable signals SH<sub>--</sub> EN and the MEM<sub>--</sub> EN are both changed to their unenabled condition thereby stopping the shifting of instructions into SRB 24 and the reading out of instructions from RAM 12, whereby the power necessary to address and read out RAM 12 will not be consumed. Consistent therewith, MMU 20 generates CE1 to enable the instructions stored in the registers of SRB 24 to be produced at its output in accordance with the SRB read out address SRB<sub>--</sub> ADDR generated by MMU 20. The most recent instruction stored in SRB 24 is in the first stage register thereof, the second most recent instruction is stored in the second stage register thereof, the third most recent instruction is stored in the third stage thereof and the N-th most recent instruction is stored in the N-th stage thereof. The SRB<sub>--</sub> ADDR is a number corresponding to the number of the stage of the shift register. For example, if the JMP<sub>--</sub> ADDR specified in the JMP- instruction is, in the sequence of instructions being executed as a loop, five addresses prior to the address of the JMP- instruction, the MMU 20 will subtract that instruction address from the address of the last instruction that was executed and produce a difference of five which will then be employed to generate the SRB<sub>--</sub> ADDR to fetch the first instruction in the loop from the fifth stage of the shift register bank 24. After that instruction is fetched to instruction buffer IR 14 and is decoded by control 16 and executed, the next instruction in the loop to be repeatedly executed, which is the fourth most recent instruction stored in is SRB 24, will be fetched as a result of MMU 20 generating an SRB<sub>--</sub> ADDR of four to read out the forth stage of SRB 24, followed by MMU 20 generating an SRB<sub>--</sub> ADDR of three to read out the third register of SRB 24, and so forth until the first register thereof is read out. The instruction in the first register, however, is the JMP- instruction again calling for execution of the instruction having the JMP<sub>--</sub> ADDR address which will again, when fetched to instruction register IR 14, be decoded by control 16 and inputted to NMU 20, whereupon MMU 20 remains in the mapping state and again begins the sequence of fetching the prior instructions from SRB 24 by generating the sequence of SRB<sub>--</sub> ADDR addresses beginning with that corresponding to the jump address JMP<sub>--</sub> ADDR until it again reaches the highest address, i.e. that of the JMP- instruction.</p><p>As can be appreciated from the foregoing description, a controller for a digital processor according to the present invention will automatically detect the presence of a loop from the execution instructions of the micro-code program as they are executed and will map the appropriate instructions into a register such as a shift register bank from which they will be executed whilst the processor is in such loop. As a result, the full benefit of the present invention is available without any special programming, command or cognisance on the part of the programmer or designer, and indeed irrespective of whether the programmer or designer is even aware of the power saving feature of the processor.</p><p>As used herein, an \"execution instruction\" means an instruction that specifies an operation that is to be performed by the digital processor in its execution or arithmetic unit as contrasted to a \"special instruction\" that specifies to the controller characteristics of the loop to be performed, such as the number of steps in the loop, the number of times the loop is to be performed, or the addresses of the beginning and/or ending instructions of the loop.</p><p>Thus, the controller of the present invention does not require additional special instructions either preceding or following a loop to specify the start or end points of the loop, or the number of instructions in the loop, or the number of times the loop is to be performed; but rather the controller determines the presence of a loop automatically from the executable micro-code instructions that execute the loop.</p><p>The operation of memory management unit 20 will now be described in relation to the diagram of FIG. 3. In memory management unit 20, program counter (PC) 202 generates an increasing sequence of numbers that correspond to the program steps. This sequence of numbers also corresponds to the addresses at which instructions are stored in RAM 12 and so are transmitted to RAM 12 as the memory address signal MEM<sub>--</sub> ADDR. If a jump instruction (JMP- or JMP+) is decoded by control 16, the jump address JMP<sub>--</sub> ADDR specified therein is loaded into program counter 202 to replace the then-existing program address and program counter 202 then counts up from that substituted jump address JMP<sub>--</sub> ADDR to generate an increasing sequence of instruction addresses therefrom. State tracking machine (STM) 210 receives from control 16 the signals indicating detection of a jump instruction (JMP- or JMP+) as well as the jump address JMP<sub>--</sub> ADDR specified by such command. In addition, state tracking machine 210 also receives the current instruction address ADDR as generated by program counter 202.</p><p>State tracking machine 210 generates signals that control operation of other portions of memory management unit 20 and of shift register bank 24 of digital controller 10. In particular, STM 210 generates counter enable signal CN<sub>--</sub> EN which enables counter 222 to count, counter reset signal CN<sub>--</sub> RST which resets the counter 222 to zero, load enable signal LD<sub>--</sub> EN which enables high address register 220 to store (load) the value of the present instruction address ADDR when enabled, and shift enable signal SH<sub>--</sub> EN which, in addition to enabling shift register bank 24, is employed by logic circuits 234 and 236 to generate chip enable signal CE1 and memory enable signal MEM<sub>--</sub> EN to control shift register bank 24 and random access memory 12, respectively.</p><p>Operation of state tracking machine 210 may best be understood with reference to the state diagram shown in FIG. 4 in conjunction with FIG. 3. At the reset or initialization state 302, shift register enable signal SH<sub>--</sub> EN is enabled so that instructions from RAM 12 are fetched into shift register bank 24 when they are fetched into instruction register 14, counter reset CN<sub>--</sub> RST is active and counter enable CN<sub>--</sub> EN is disabled so that counter 222 is reset to zero and does not count, and load enable LD-EN is enabled so that high address register 220 is loaded with the address ADDR of the instruction presently being executed, i.e. that produced by program counter 202, as the system moves into the non-mapping state 304. In the non-mapping state 304, decoding of a jump back JMP- instruction by control 16 indicates that a loop is being executed and has been detected by control 16. For purposes of description, consider first the other conditions of the non-mapping state. If a jump ahead JMP+ instruction is decoded by control 16, it is not an indication of a loop and tracking machine 210 follows track 306 to remain in the non-mapping state 304 with the same conditions of the shift enable signal SH<sub>--</sub> EN, counter reset signal CN<sub>--</sub> RST, counter enable CN<sub>--</sub> EN and load enable LD<sub>--</sub> EN signals as established in the reset condition or reset state 302. If any other instruction is decoded by control 16, as indicated by \"else\", track 308 keeps the program in the non-mapping state 304 but with the counter reset CN<sub>--</sub> RST disabled and the counter enable CN<sub>--</sub> EN enabled so that counter 222 counts the number of instructions thereafter stored in shift register bank 24. In this state, which is the normal execution condition when the digital processor is not executing a loop, instructions to be executed are being fetched from RAM 12 to instruction register 14 and SRB 24 and the address of the current instruction generated by program counter 202 is being stored in high address register 220 of memory management unit 20. As thus far described, shift enable signal SH<sub>--</sub> EN is in the enabling condition to enable shift register bank 24 and so is applied to AND gate 234 through an inverting input (as indicated by the circle at the input to AND gate 234) so that enable CE1 must be disabled. The application of shift enable signal SH<sub>--</sub> EN to OR gate 236 must produce a true condition at its output so that memory enable signal MEM-EN enables RAM 12 from which instructions to be executed are able to be fetched.</p><p>Returning to FIG. 4, when a jump back JMP- instruction is decoded by controller 16 state tracking machine 210 moves along track 310 from non-mapping state 304 to mapping state 320. This change from the non-mapping 304 to the mapping state 320 causes changes in the shift enable SH<sub>--</sub> EN, the counter reset CN-RST and the load enable LD<sub>--</sub> EN signals to their respective disabled states. With these signals all in the disabled condition: shift register bank 24 retains the last up to N instructions (where N is the number of stages in shift register bank 24) that had been fetched from RAM 12, counter 222 holds the number then stored therein which corresponds to the number of valid instructions (up to N) that are stored in shift register bank 24, and high address register 220 stores the address of the last instruction that was executed, i.e. the address of the jump back JMP- instruction, and the target address JMP<sub>--</sub> ADDR is stored in register 212 of state tracking machine 210 as JMP<sub>--</sub> ADDR<sub>--</sub> ST.</p><p>In the mapping state 320, with shift enable SH<sub>--</sub> EN disabled, AND gate 234 and OR gate 236 are able to respond to the other inputs thereto. When the jump target address JMP<sub>--</sub> ADDR specified by the jump back instruction JMP- is within the range of instructions stored in shift register bank 24, operation proceeds as follows: the high address stored in high address register 220 is applied to subtraction unit 224 in which the number stored in counter 222 is subtracted therefrom. Accordingly, the output of subtractor 224 is the address of the one of the sequence of valid instructions most recently stored in SRB 24 that has the lowest address in that sequence, i.e. it is the valid instruction that is most deeply stored in shift register bank 24. If the lowest valid address of the instructions stored in shift register bank 224 is less than the present address, then it is acceptable to enable RAM 12 and SRB 24 in the mapping state 320. This determination is made by comparator 230 which produces a true output if the address of the instruction in shift register bank 24 having the lowest valid address is less than the present address produced by program counter 202. Comparator 232 compares the high address stored in high address register 220 with the present instruction address generated by program counter 202 and, if the high address stored in register 220 is greater than the present address, then the output of comparator 232 is true indicating that the controller is possibly in a loop and that the mapping may proceed if the instruction required is within the range of those stored in shift register bank 24. With the output of comparators 230 and 232 being true, and with shift enable signal SH<sub>--</sub> EN being untrue (disabling), AND gate 234 produces a true output in the mapping state to generate a chip enable signal CE1 to enable shift register bank 24 to produce at its output the instructions stored therein in accordance with the shift register address signal SRB<sub>--</sub> ADDR. Shift register address signal SRB<sub>--</sub> ADDR is generated by subtractor 240 subtracting the address of the present instruction produced by program counter 202 from the high address stored in high address register 220. Because chip enable signal CE1 is enabled, AND gate 234 applies a true signal to the inverting input (as indicated by the circle) of OR gate 236 which produces a memory enable signal MEM<sub>--</sub> EN that is not enabling of RAM 12. As a result, instructions are fetched from shift register bank 24 so long as state tracking machine 210 and controller 10 remain in the mapping state 320.</p><p>It is important to note that if the jump target address JMP<sub>--</sub> ADDR is outside the range of valid instructions stored in SRB 24, it is not acceptable to enable the mapping operation wherein instructions are fetched from shift register bank 24. When the JMP<sub>--</sub> ADDR is outside the range of SRB 24, the output of comparator 230 will not be true and AND gate 234 will hold chip enable CE1 to shift register bank 24 in a disable condition and OR gate 236 will hold memory enable signal MEM<sub>--</sub> EN in an enable condition so that the addressed instruction will be fetched from memory 12. At any time when the instruction called for by program counter 202 has an address within the range of the instructions stored in shift register bank 24, comparators 230 and 232 will produce true outputs as described above, which will result in shift register bank 24 being enabled to fetch the instructions stored therein in accordance with the shift register address signal SRB<sub>--</sub> ADDR specified.</p><p>In this manner, the shift register bank 24 becomes the source of instructions to be executed whenever the instructions in the shift register bank 24 are called for by program counter 202, whereby random access memory 12 is not accessed anytime there is a valid instruction stored in shift register bank 24 that can be fetched and so power consumption tends to be minimized under any condition of loops. All this is done in response to execution instructions without need for any special instruction and without any action being required of or taken by the programmer.</p><p>Returning again to FIG. 4, system 10 and state tracking machine 210 remain in the mapping state 320 unless certain instruction decoding conditions are satisfied. If these conditions are not satisfied, state tracking machine 210 determines an \"else\" condition 324 which retains state tracking machine 210 in the mapping state 320 with the shift enable signal SH<sub>--</sub> EN, counter reset signal CN<sub>--</sub> RST, counter enable signal CN<sub>--</sub> EN, and load enable signal LD<sub>--</sub> EN all in the disabled state. This condition corresponds to the condition that obtains as a result of the jump from non-mapping state 304 to mapping state 320 along path 310.</p><p>The conditions which cause state tracking machine 210 to exit mapping state 320 are those in which the present instruction loop is no longer active. These include the condition where a jump forward JMP+ instruction is decoded by control 16 indicating that the processor is either not in a loop or has jumped out of a loop. In addition, state tracking machine 210 will exit mapping state 320 along path 322 to non-mapping state 304 if a different loop is detected by control 16. This occurs when another (more recent) jump back JMP- instruction is decoded by control 16 and the address ADDR of the more recent jump back JMP- instruction differs from the address HIGH<sub>--</sub> REG<sub>--</sub> ADDR stored in the high address register 220 for the previous jump back JMP- instruction and the jump target address JMP<sub>--</sub> ADDR specified by the more recent jump back JMP- instruction is different from the jump target address JMP<sub>--</sub> ADDR of the jump instruction of the previous loop instruction. To this end, state tracking machine 210 includes internal registers 212 into which the instruction address ADDR and jump target address JMP<sub>--</sub> ADDR specified in the jump back JMP- instruction loop being mapped is stored, which stored address and stored jump address are indicated by ADDR<sub>--</sub> ST and JMP<sub>--</sub> ADDR<sub>--</sub> ST, respectively. If the next (after the first) jump back JMP- instruction decoded by control 16 does not have the same jump instruction address ADDR as the previously detected jump back JMP- instruction ADDR<sub>--</sub> ST and does not have the same jump target address JMP<sub>--</sub> ADDR as that JMP<sub>--</sub> ADDR<sub>--</sub> ST of the previously detected jump back JMP- instruction, then state tracking machine 210 moves from mapping state 320 along path 322 to non-mapping state 304 and controller 10 reverts to loading instructions from memory 12 i