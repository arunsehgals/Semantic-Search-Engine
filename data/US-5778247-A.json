 code 66 indicates that it is a floating point ADD and the \"s\" at the end indicates that it is single precision. The operands used by the instructions are indicated by register designations 68 and 70, which refer to registers F0 and F1. A destination register is indicated by designation 72, referring to a register F3. Since this is a single precision operand, as indicated by the OP code, the F0 designation refers to the single precision F0 position 74 in FIG. 2, the F1 refers to position 76 and the F3 designation refers to position 78, which is the second half of line 64 in register file 60 of FIG. 2.</p><p>FIG. 4B illustrates a different instruction in which OP code 80 indicates an integer ADD that is double precision. The register designations of F0 and F2 for the operand registers and F6 for the destination register are thus double precision designations. F0 refers to line 12 in register file 60 of FIG. 2, thus intersecting single precision F0 and F1. Similarly, F2 refers to entry 64 in FIG. 2, and F6 refers to entry 82, both of which would collide with two separate single precision registers.</p><p>As can be seen, it is thus necessary to determine whether the register designation corresponds to a single or double precision OP code in order to determine data dependencies. In determining a data dependency for a new instruction of FIG. 4B, if FIG. 4A is outstanding, the writing of the complete result into F3 must occur before the instruction of FIG. 4B can access its register F1, since they use the same entry line as indicated in FIG. 2.</p><p>FIG. 5 illustrates a portion of the microprocessor of FIG. 1 in more detail. In particular, load/store unit 32 is shown and functional units 36 and 34.</p><p>FIG. 6 illustrates the floating point and graphics functional units of FIG. 1, with the same load/store unit 88.</p><p>FIG. 7 is a block diagram showing the dispatch unit 28 of FIG. 1 in more detail. Control logic 90 determines which functional unit each instruction should be dispatched to, depending upon availability of the functional units and any other required resources. Two functional units are shown for illustrative purposes, load/store unit 32 and integer ALU functional unit 36. Before dispatching instructions to a first group of functional units (all functional units except for the load/store units), control logic 90 checks the precision mode in register 92. If the instructions to be dispatched have the same precision as those in the pipeline, as indicated by the mode bit in register 92, the instructions will be dispatched, with data dependencies being checked assuming register designations are all the same precision. Otherwise, the instructions will be stalled until the pipeline is empty, as indicated by an empty bit in mode register 92.</p><p>If an instruction is intended for load/store unit 32, then it is allowed to proceed regardless of whether its precision matches that of preceding instructions in the load/store pipeline. The control logic will not modify the mode bit on the basis of instructions in or provided to load/store unit 32, and checks the precision of register designations when checking data dependencies for providing instructions to the load/store functional unit.</p><p>The mode bit is set by an OP code decode logic block 94. Logic 94 decodes each instruction's OP code to determine whether it is single or double precision, and sets mode bit 92 accordingly when the instruction is dispatched into the pipeline.</p><p>In the illustrative diagram, integer ALU 36 is shown as a first block 96 including the actual functional logic, and a narrower block 98, which is the register designation carried along through the pipeline. The register designations are provided back to data dependency logic 100 and functional unit 28. There, data dependency logic 100 can compare the registers designated by new instructions to be dispatched by control logic 90 to the register designations in the pipeline as indicated by logic 98. Similar logic would be included for each of the other functional units and provided to data dependency logic 100. As can be seen, this logic is fairly simple, since there is no need to provide the OP code for each stage of the pipeline of the functional units. Data dependency logic 100 simply assumes that the register designation of the new and existing instructions are of the same precision.</p><p>In the load/store functional unit 32, on the other hand, there is provided the actual functional logic indicated by block 102, the register usage logic 104, and an additional OP code logic 106. OP code logic 106 indicates to data dependency logic 100 whether the instructions in each stage of the load/store functional unit pipeline are single or double precision. The data dependency logic includes an additional set of logic for using this information to determine data dependencies for a new instruction about to be dispatched by control logic 90.</p><p>As can be seen, the present invention thus provides the savings of not requiring logic 106 for each of the functional units, and also not requiring corresponding logic and data dependency logic 100 for each of the functional units. Instead, this is only required for the load/store functional units.</p><p>In addition, referring back to FIGS. 5 and 6, bypass precision logic 52 of FIG. 5 and 54 of FIG. 6 is used for the load/store units 32 of FIG. 5 and 110 of FIG. 6 to determine whether a bypassing of the completion unit should be allowed where there is a mixture of single and double precision numbers. The other functional units eliminate this logic, allowing a bypass regardless of whether the bypass instruction is a different precision from the other instructions in the pipeline. Since the pipeline will not be allowed to have instructions of different precision, this condition will never occur, thus eliminating the need for this additional checking logic.</p><p>FIG. 8 is a state diagram illustrating the three states of the precision indicator of the present invention. In a first, single state 112, single precision operands are present in the pipeline. In a second, double precision state 114, double precision operands are present in the pipeline. In an empty state 116, the pipeline is empty of active and valid instructions.</p><p>Starting at empty state 116, upon a single precision instruction being dispatched, the state of the machine will transition as indicated by line 118 to the single precision state 112. As soon as the last single precision instruction has flowed through the pipeline, there will be a transition back to the empty state as indicated by arrow 120. Similarly, for double precision, a double precision instruction being dispatched will transition the state from empty state 116 as indicated by arrow 122 to double precision state 114. When the last double precision operand has exited the pipeline, there will be a transition back to empty state 116 as indicated by arrow 124.</p><p>Alternately, there may be a transition from a single to double precision state as indicated by arrow 126, or the reverse as indicated by arrow 128. These are indicated as dotted lines to show that they are optional. A direct transition would require logic to confirm that the instructions in the pipeline will complete in the next cycle so that there would not interference. Since this requires additional logic and would take additional time, it would be simpler to simply require that the pipeline be empty. Since transitions from single to double precision rarely occur, i.e., changing from one program to another might cause such an occurrence, the impact on throughput is negligible.</p><p>In indicating an empty state, the pipeline need not actually be empty of instructions. For example, in the case of a mispredicted branch, the instructions in the pipeline may simply be invalidated, rather than waiting for the multiple cycles required to physically empty the pipeline of the mispredicted instructions and start the new, corrected branch of instructions.</p><p>The load pipeline is an exception to the general rule that single and double precision rarely mix. It is possible, for instance, to load a single precision operand to register F0, another single precision operand to register F1, and then do a double precision operation using F0, which is the combination of F0 and F1. Fortunately, the load/save pipeline is shorter than the other pipelines, thus allowing much simpler logic to determine the operand and whether it is single or double precision.</p><p>When a change in a precision occurs, dispatching of instructions to the pipeline is halted until the pipeline empties. For example, in the Ultrasparc\u2122 microprocessor, this would normally be seven cycles or less, unless there is a floating point square root or divide operation, which could take as much as 22 cycles, for instance. However, the probability of a switch in precision at the same time as a 22-cycle operation being processed is so remote that simply waiting for the 22 cycles to complete is not a significant performance factor.</p><p>Although the foregoing description refers to single and double precision, the present invention is applicable to quad precision or other precision levels with varying amounts of bits. In one embodiment, a quad precision operation would require a trap to software. In a preferred embodiment, any trap to software results in waiting for the pipeline to empty, thus dealing with the requirement of having the same precision in the pipeline at one time. Accordingly, a software emulation of a quad precision operation which waits for the pipeline to flush upon a software trap also does not need the logic which has been eliminated by the present invention, and can assume register designations are for the same precision.</p><p>As will be understood by those with skill in the art, the present invention may be embodied in other specific forms without departing from the spirit or essential characters thereof. For example, different numbers of functi