 number of bits from the address are used as an \u201cindex\u201d into the cache. The index selects a particular row within the two-dimensional array, and therefore the number of address bits required for the index is determined by the number of rows configured into the cache. The act of selecting a row via an index is referred to as \u201cindexing\u201d. The addresses associated with bytes stored in the multiple cache lines of a row are examined to determine if any of the addresses match the requested address. If a match is found, the access is said to be a \u201chit\u201d, and the cache provides the associated bytes. If a match is not found, the access is said to be a \u201cmiss\u201d. When a miss is detected, the bytes are transferred from the memory system into the cache. The addresses associated with bytes stored in the cache are also stored. These stored addresses are referred to as \u201ctags\u201d or \u201ctag addresses\u201d.</p><p>The cache lines within a row form the columns of the row. Columns may also be referred to as \u201cways\u201d. The column is selected by examining the tags from a row and finding a match between one of the tags and the requested address. A cache designed with one column per row is referred to as a \u201cdirect-mapped cache\u201d. In a direct-mapped cache, the tag must be examined to determine if an access is a hit, but the tag examination is not required to select which bytes are transferred to the outputs of the cache.</p><p>In addition to employing caches, superscalar microprocessors often employ speculative execution to enhance performance. An instruction may be speculatively executed if the instruction is executed prior to determination that the instruction is actually to be executed within the current instruction stream. Other instructions which precede the instruction in program order may cause the instruction not to be actually executed (i.e. a mispredicted branch instruction or an instruction which causes an exception). If an instruction is speculatively executed and later determined to not be within the current instruction stream, the results of executing the instruction are discarded. Unfortunately, store memory accesses are typically not performed speculatively. As used herein, a \u201cmemory access\u201d refers to a transfer of data between one or more main memory storage locations and the microprocessor. A transfer from memory to the microprocessor (a \u201cread\u201d) is performed in response to a load memory access. A transfer from the microprocessor to memory (a \u201cwrite\u201d) is performed in response to a store memory access. Memory accesses may be a portion of executing an instruction, or may be the entire instruction. A memory access may be completed internal to the microprocessor if the memory access hits in the data cache therein. As used herein, \u201cprogram order\u201d refers to the sequential order of instructions specified by a computer program.</p><p>While speculative load memory accesses are often performed, several difficulties typically prevent implementation of speculative store memory accesses. As opposed to registers which are private to the microprocessor, memory may be shared with other microprocessors or devices. Although the locations being updated may be stored in the data cache, the data cache is required to maintain coherency with main memory. In other words, an update performed to the data cache is recognized by other devices which subsequently access the updated memory location. Other devices must not detect the speculative store memory access, which may later be canceled from the instruction processing pipeline due to incorrect speculative execution. However, once the store becomes non-speculative, external devices must detect the corresponding update. Additionally, speculative loads subsequent to the speculative store within the microprocessor must detect the updated value even while the store is speculative.</p><p>Instead of speculatively performing store memory accesses, many superscalar microprocessors place the store memory accesses in a buffer. When the store memory accesses become non-speculative, they are performed. Load memory accesses which access memory locations updated by a prior store memory access may be stalled until the store memory access completes, or may receive forwarded data from the store memory access within the buffer. Even when forwarding is implemented, the load memory access is stalled for cases in which the load memory access is not completely overlapped by the store memory access (i.e. the load memory access also reads bytes which are not updated by the store memory access). Buffer locations occupied by stores and loads which depend upon those stores are not available to subsequent memory accesses until the store is performed. Performance of the microprocessor is thereby decreased due to the inability to perform speculative store memory accesses. An apparatus allowing speculative performance of store memory accesses while ensuring correct operation is desired.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by an apparatus for performing speculative stores. The apparatus reads the original data from a cache line being updated by a speculative store, storing the original data in a restore buffer. The speculative store data is then stored into the affected cache line. Should the speculative store later be canceled, the original data may be read from the restore buffer and stored into the affected cache line. The cache line is thereby returned to a pre-store state. In one embodiment, the cache is configured into banks. The data read and restored comprises the data from one of the banks which comprise the affected cache line. Advantageously, store memory accesses are performed speculatively. Since the store memory access has already been performed, the store memory access may immediately be discarded by the load/store unit when the corresponding instruction is retired. Performance may be increased by more efficient release of load/store buffer space. Additionally, the reorder buffer may retire subsequent instructions more quickly. Reorder buffer efficiency may thereby be increased. Still further, store throughput may be increased due to the speculative performance of the cache access. Cache access and hit determination need not be performed between receipt of a retirement indication from the reorder buffer and a signal from the load/store unit that the store memory access is completed. Subsequent stores may then be indicated as ready to retire earlier. The ability to restore the original data to the cache line enables correct operation in the case of incorrect execution of the speculative store or a snoop hit.</p><p>As opposed to many prior load/store units, the load/store unit described herein does not perform forwarding of store data to subsequent load memory accesses. Instead, since the store is speculatively performed to the data cache, the loads may access the data cache. Dependency checking between loads and stores prior to the speculative performance of the store may stall the load memory access until the corresponding store memory access has been performed. Advantageously, forwarding logic is not employed by the load/store unit. Similar functionality is obtained through the performance of load memory accesses to the data cache. Additionally, speculative load memory accesses which are partially overlapped by a prior speculative store memory access may be performed more efficiently. The data cache, subsequent to the speculative store, contains each of the bytes accessed by the load memory access.</p><p>Broadly speaking, the present invention contemplates an apparatus for performing speculative stores in a microprocessor comprising a first buffer, a first control unit, a cache and a second buffer. The first buffer is configured to store a plurality of store memory accesses. Coupled to the first buffer, the first control unit is configured to select at least one of the plurality of store memory accesses for cache access, and wherein the selected store memory access is speculative. The cache is coupled to receive the selected store memory access, and is configured to read first data from a cache line accessed by the selected store memory access. Additionally, the cache is configured to store second data corresponding to the selected store memory access into the cache line subsequent to reading the first data. The second buffer is coupled to the cache and is configured to store the first data. The first control unit is configured to receive an indication that the selected store memory access is incorrectly executed. In response to the indication, the first control unit is configured to convey the selected store memory access to the cache. The cache is configured to store the first data into the cache line in response to the indication, whereby the first data is restored to the cache line when the selected store memory access is incorrectly executed.</p><p>The present invention further contemplates a method for performing speculative store memory accesses in a microprocessor, comprising several steps. First data is read from a cache line accessed by a store memory access. Second data corresponding to the store memory access is stored into the cache line subsequent to the reading. The first data is restored to the cache line in response to an indication that the store memory access is incorrectly executed.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a superscalar microprocessor.</p><p>FIG. 2 is a block diagram of a pair of decode units shown in FIG. 1, according to one embodiment of the microprocessor.</p><p>FIG. 3 is a block diagram of a load/store unit and a data cache shown in FIG. 1, according to one embodiment of the microprocessor.</p><p>FIG. 3A is a timing diagram showing events for a load memory access which hits in an unpredicted column.</p><p>FIG. 3B is a timing diagram showing events for a store memory access which hits in a predicted column.</p><p>FIG. 3C is a timing diagram showing events for a store memory access which hits in an unpredicted column.</p><p>FIG. 3D is a timing diagram showing events for a store memory access which misses.</p><p>FIG. 4A is a diagram showing information stored in a load/store buffer within the load/store unit shown in FIG. 3, according to one embodiment of the load/store unit.</p><p>FIG. 4B is a diagram showing information stored in a restore buffer within the data cache shown in FIG. 3, according to one embodiment of the data cache.</p><p>FIG. 5 is a flow chart illustrating operation of one embodiment of the load/store unit.</p><p>FIG. 6 is a block diagram of a computer system including the microprocessor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>Turning now to FIG. 1, a block diagram of one embodiment of a microprocessor <b>10</b> is shown. Microprocessor <b>10</b> includes a prefetch/predecode unit <b>12</b>, a branch prediction unit <b>14</b>, an instruction cache <b>16</b>, an instruction alignment unit <b>18</b>, a plurality of decode units <b>20</b>A-<b>20</b>C, a plurality of reservation stations <b>22</b>A-<b>22</b>C, a plurality of functional units <b>24</b>A-<b>24</b>C, a load/store unit <b>26</b>, a data cache <b>28</b>, a register file <b>30</b>, a reorder buffer <b>32</b>, and an MROM unit <b>34</b>. Blocks referred to herein with a reference number followed by a letter will be collectively referred to by the reference number alone. For example, decode units <b>20</b>A-<b>20</b>C will be collectively referred to as decode units <b>20</b>.</p><p>Prefetch/predecode unit <b>12</b> is coupled to receive instructions from a main memory subsystem (not shown), and is coupled to instruction cache <b>16</b>. Similarly, branch prediction unit <b>14</b> is coupled to instruction cache <b>16</b>. Still further, branch prediction unit <b>14</b> is coupled to decode units <b>20</b> and functional units <b>24</b>. Instruction cache <b>16</b> is further coupled to MROM unit <b>34</b> and instruction alignment unit <b>18</b>. Instruction alignment unit <b>18</b> is in turn coupled to decode units <b>20</b>. Each decode unit <b>20</b>A-<b>20</b>C is coupled to load/store unit <b>26</b> and to respective reservation stations <b>22</b>A-<b>22</b>C. Reservation stations <b>22</b>A-<b>22</b>C are further coupled to respective functional units <b>24</b>A-<b>24</b>C. Additionally, decode units <b>20</b> and reservation stations <b>22</b> are coupled to register file <b>30</b> and reorder buffer <b>32</b>. Functional units <b>24</b> are coupled to load/store unit <b>26</b>, register file <b>30</b>, and reorder buffer <b>32</b> as well. Data cache <b>28</b> is coupled to load/store unit <b>26</b> and to the main memory subsystem. Finally, MROM unit <b>34</b> is coupled to decode units <b>20</b>.</p><p>Generally speaking, load/store unit <b>26</b> and data cache <b>28</b> operate together to perform speculative store memory accesses. Load/store unit <b>26</b> selects a speculative store memory access for performance based upon a predetermined set of criteria, and conveys the store memory access to data cache <b>28</b>. Prior to performing the store, data cache <b>28</b> copies the corresponding data within the affected cache line into a restore buffer. Load/store unit <b>26</b> retains the speculative store memory access until either the store memory access retires or until an indication to restore the speculative store memory accesses is received. Speculative stores are restored (i.e. the cache line is returned to the pre-store state) if an instruction prior to the speculative stores is a mispredicted branch or an instruction which experiences an exception. Additionally, a restore is performed if a snoop is detected which requires data cache <b>28</b> to write a cache line to main memory. It is noted that, in the case of a restore in response to a snoop, the store memory access is retained by load/store unit <b>26</b> and performed to data cache <b>28</b> again after the snoop is serviced. Load/store unit <b>26</b> conveys the address of a store requiring restoration, and asserts a restore indication to data cache <b>28</b>. Data cache <b>28</b> accesses the restore buffer and writes the data stored therein to the cache line accessed by the speculative store address. The original data is thereby restored to the cache line. Advantageously, store memory accesses are performed speculatively. Since the store memory access has already been performed, the store memory access may immediately be cleared from the load/store buffer when reorder buffer <b>32</b> indicates that the store is ready to be retired. Performance may be increased by more efficient release of load/store buffer space. Additionally, reorder buffer <b>32</b> may progress to retiring subsequent instructions more quickly. Reorder buffer efficiency may thereby be increased. Still further, store throughput may be increased. Previously, stores were indicated to be non-speculative during a clock cycle. The store then accessed data cache <b>28</b> and determined if the store hit the cache before indicating to reorder buffer <b>32</b> that the store is complete and clearing the corresponding load/store buffer storage location. Subsequent stores were not indicated as non-speculative until the cache access and hit determination were made. Because cache access and hit determination are performed prior to indication that the store is non-speculative in load/store unit <b>26</b>, the store may be completed immediately upon non-speculative indication. The ability to restore the original data to the cache line enables correct operation in the case of incorrect execution of the speculative store or a snoop hit.</p><p>As opposed to many prior load/store units, load/store unit <b>26</b> does not perform forwarding of store data to subsequent load memory accesses. Instead, since the store is speculatively performed to data cache <b>28</b>, the loads may access data cache <b>28</b>. Dependency checking between loads and stores prior to the speculative performance of the store stalls the load memory access until the corresponding store memory access has been performed. Advantageously, forwarding logic is not employed by load/store unit <b>26</b>. Similar functionality is obtained through the performance of load memory accesses to data cache <b>28</b>. Additionally, speculative loads which are partially overlapped by a prior speculative store may be performed more efficiently. Data cache <b>28</b>, subsequent to the speculative store, contains each of the bytes accessed by the load.</p><p>Instruction cache <b>16</b> is a high speed cache memory provided to store instructions. Instructions are fetched from instruction cache <b>16</b> and dispatched to decode units <b>20</b>. In one embodiment, instruction cache <b>16</b> is configured to store up to 32 kilobytes of instructions in an 8 way set associative structure having 16 byte lines (a byte comprises 8 binary bits). Instruction cache <b>16</b> may additionally employ a way prediction scheme in order to speed access times to the instruction cache. Instead of accessing tags identifying each line of instructions and comparing the tags to the fetch address to select a way, instruction cache <b>16</b> predicts the way that is accessed. In this manner, the way is selected prior to accessing the instruction storage. The access time of instruction cache <b>16</b> may be similar to a direct-mapped cache. A tag comparison is performed and, if the way prediction is incorrect, the correct instructions are fetched and the incorrect instructions are discarded. It is noted that instruction cache <b>16</b> may be implemented as a fully associative, set associative, or direct mapped configuration.</p><p>Instructions are fetched from main memory and stored into instruction cache <b>16</b> by prefetch/predecode unit <b>12</b>. Instructions may be prefetched prior to instruction cache <b>16</b> recording a miss for the instructions in accordance with a prefetch scheme. A variety of prefetch schemes may be employed by prefetch/predecode unit <b>12</b>. As prefetch/predecode unit <b>12</b> transfers instructions from main memory to instruction cache <b>16</b>, prefetch/predecode unit <b>12</b> generates three predecode bits for each byte of the instructions: a start bit, an end bit, and a functional bit. The predecode bits form tags indicative of the boundaries of each instruction. The predecode tags may also convey additional information such as whether a given instruction can be decoded directly by decode units <b>20</b> or whether the instruction is executed by invoking a microcode procedure controlled by MROM unit <b>34</b>, as will be described in greater detail below.</p><p>One encoding of the predecode tags for an embodiment of microprocessor <b>10</b> employing the x86 instruction set will next be described. If a given byte is the first byte of an instruction, the start bit for that byte is set. If the byte is the last byte of an instruction, the end bit for that byte is set. Instructions which may be directly decoded by decode units <b>20</b> are referred to as \u201cfast path\u201d instructions. The remaining x86 instructions are referred to as MROM instructions, according to one embodiment. For fast path instructions, the functional bit is set for each prefix byte included in the instruction, and cleared for other bytes. Alternatively, for MROM instructions, the functional bit is cleared for each prefix byte and set for other bytes. The type of instruction may be determined by examining the functional bit corresponding to the end byte. If that functional bit is clear, the instruction is a fast path instruction. Conversely, if that functional bit is set, the instruction is an MROM instruction. The opcode of an instruction may thereby be located within an instruction which may be directly decoded by decode units <b>20</b> as the byte associated with the first clear functional bit in the instruction. For example, a fast path instruction including two prefix bytes, a Mod R/M byte, and an SIB byte would have start, end, and functional bits as follows:</p><p><tables id=\"TABLE-US-00001\"><table colsep=\"0\" frame=\"none\" rowsep=\"0\"><tgroup align=\"left\" cols=\"3\" colsep=\"0\" rowsep=\"0\"><colspec align=\"left\" colname=\"OFFSET\" colwidth=\"49PT\"></colspec><colspec align=\"left\" colname=\"1\" colwidth=\"49PT\"></colspec><colspec align=\"center\" colname=\"2\" colwidth=\"119PT\"></colspec><thead valign=\"bottom\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></thead><tbody valign=\"top\"><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Start bits</entry><entry morerows=\"0\" valign=\"top\">10000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">End bits</entry><entry morerows=\"0\" valign=\"top\">00001</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry morerows=\"0\" valign=\"top\">Functional bits</entry><entry morerows=\"0\" valign=\"top\">11000</entry></row><row><entry morerows=\"0\" valign=\"top\"></entry><entry align=\"center\" morerows=\"0\" nameend=\"2\" namest=\"OFFSET\" rowsep=\"1\" valign=\"top\"></entry></row></tbody></tgroup></table></tables></p><p>MROM instructions are instructions which are determined to be too complex for decode by decode units <b>20</b>. MROM instructions are executed by invoking MROM unit <b>34</b>. More specifically, when an MROM instruction is encountered, MROM unit <b>34</b> parses and issues the instruction into a subset of defined fast path instructions to effectuate the desired operation. MROM unit <b>34</b> dispatches the subset of fast path instructions to decode units <b>20</b>. A listing of exemplary x86 instructions categorized as fast path instructions will be provided further below.</p><p>Microprocessor <b>10</b> employs branch prediction in order to speculatively fetch instructions subsequent to conditional branch instructions. Branch prediction unit <b>14</b> is included to perform branch prediction operations. In one embodiment, up to two branch target addresses are stored with respect to each cache line in instruction cache <b>16</b>. Prefetch/predecode unit <b>12</b> determines initial branch targets when a particular line is predecoded. Subsequent updates to the branch targets corresponding to a cache line may occur due to the execution of instructions within the cache line. Instruction cache <b>16</b> provides an indication of the instruction address being fetched, so that branch prediction unit <b>14</b> may determine which branch target addresses to select for forming a branch prediction. Decode units <b>20</b> and functional units <b>24</b> provide update information to branch prediction unit <b>14</b>. Because branch prediction unit <b>14</b> stores two targets per cache line, some branch instructions within the line may not be stored in branch prediction unit <b>14</b>. Decode units <b>20</b> detect branch instructions which were not predicted by branch prediction unit <b>14</b>. Functional units <b>24</b> execute the branch instructions and determine if the predicted branch direction is incorrect. The branch direction may be \u201ctaken\u201d, in which subsequent instructions are fetched from the target address of the branch instruction. Conversely, the branch direction may be \u201cnot taken\u201d, in which subsequent instructions are fetched from memory locations consecutive to the branch instruction. When a mispredicted branch instruction is detected, instructions subsequent to the mispredicted branch are discarded from the various units of microprocessor <b>10</b>. A variety of suitable branch prediction algorithms may be employed by branch prediction unit <b>14</b>.</p><p>Instructions fetched from instruction cache <b>16</b> are conveyed to instruction alignment unit <b>18</b>. As instructions are fetched from instruction cache <b>16</b>, the corresponding predecode data is scanned to provide information to instruction alignment unit <b>18</b> (and to MROM unit <b>34</b>) regarding the instructions being fetched. Instruction alignment unit <b>18</b> utilizes the scanning data to align an instruction to each of decode units <b>20</b>. In one embodiment, instruction alignment unit <b>18</b> aligns instructions from three sets of eight instruction bytes to decode units <b>20</b>. Instructions are selected independently from each set of eight instruction bytes into preliminary issue positions. The preliminary issue positions are then merged to a set of aligned issue positions corresponding to decode units <b>20</b>, such that the aligned issue positions contain the three instructions which are prior to other instructions within the preliminary issue positions in program order. Decode unit <b>20</b>A receives an instruction which is prior to instructions concurrently received by decode units <b>20</b>B and <b>20</b>C (in program order). Similarly, decode unit <b>20</b>B receives an instruction which is prior to the instruction concurrently received by decode unit <b>20</b>C in program order.</p><p>Decode units <b>20</b> are configured to decode instructions received from instruction alignment unit <b>18</b>. Register operand information is detected and routed to register file <b>30</b> and reorder buffer <b>32</b>. Additionally, if the instructions require one or more memory operations to be performed, decode units <b>20</b> dispatch the memory operations to load/store unit <b>26</b>. Each instruction is decoded into a set of control values for functional units <b>24</b>, and these control values are dispatched to reservation stations <b>22</b> along with operand address information and displacement or immediate data which may be included with the instruction.</p><p>Microprocessor <b>10</b> supports out of order execution, and thus employs reorder buffer <b>32</b> to keep track of the original program sequence for register read and write operations, to implement register renaming, to allow for speculative instruction execution and branch misprediction recovery, and to facilitate precise exceptions. A temporary storage location within reorder buffer <b>32</b> is reserved upon decode of an instruction that involves the update of a register to thereby store speculative register states. If a branch prediction is incorrect, the results of speculatively-executed instructions along the mispredicted path can be invalidated in the buffer before they are written to register file <b>30</b>. Similarly, if a particular instruction causes an exception, instruc