In microprocessors of the like for general use instead of specializing in digital signal processing, a repeat instruction is not necessarily supported. In order to be provided with a repeat instruction, an instruction buffer or a repeat control circuit has to be introduced into them. Since, moreover, a repeat control circuit needs many items of hardware such as a repeat start address register, a repeat end address register, a repeat count register, a comparator and a down counter, this is based on a way of thinking that increasing the circuitry scale by introducing such a repeat control circuit is not necessarily advantageous to a microprocessor.</p><p>Further, in loop processing emerging in an actual processing, not only simple repetitions but also loops of diverse structures emerge. They include loops to which the control method of reading instructions reiteratively out of the aforementioned instruction buffer cannot be applied as a matter of principle. For instance, where a loop has a plurality of routes of which a different one is followed according to the number of repetitions of the loop, the aforementioned instruction buffer, in which only the instruction executed over the first route is stored, is incompatible with the second and subsequent loops. Therefore the microprocessor should be provided with a means to prohibit the application of control to read instructions reiteratively out of the instruction buffer depending on the structure of the loop. However, as the digital signal processors of Prior Art 1 and Prior Art 2 are provided with no such means and, on every occasion of loop processing, control to reiteratively read out instructions out of the instruction buffer is effected, they involve the problem that correct program processing cannot be accomplished when they come across a loop of a structure to which control to reiteratively read out instructions from the instruction buffer cannot be applied.</p><p>On the other hand, a technique to increase the speed or program processing by having, during the execution of loop processing, every instruction in the loop stay in a cache memory without fail is described in the Japanese Patent Laid-open No. 333929/1992 (hereinafter referred to as Prior Art 3). According to Prior Art 3, irrespective of whether or not loop processing is being executed, the cache memory operates whenever an instruction is read (unless miscaching is committed). In order to reduce the power spent in loop processing, the capacity of the cache memory itself should be reduced. However, there is the problem that, as the same small capacity memory is accessed even during non-loop processing, the hit ratio drops, making it impossible to increase the speed of program processing.</p><p>An object of the present invention is to provide a data processing apparatus provided with a control means which, in spite of the unavailability of a repeat instruction, reduces the power needed for memory accessing by reading instructions from a small scale buffer reiteratively during loop processing.</p><p>Another object of the invention is to provide a data processing apparatus provided with a means to opt to apply, or not to apply, control to read reiteratively, from a small scale buffer, instructions to be reiteratively executed during loop processing.</p><p>The aforementioned and other objects and novel features of the invention will become apparent from the description in this specification and accompanying drawings.</p><p>The following is a brief description of the typical aspects of the invention disclosed in this application.</p><p>Thus, a data processing apparatus (<b>100</b>, <b>700</b>, <b>900</b>, <b>1400</b> or <b>1600</b>) for executing instructions stored in a first instruction storing means (<b>102</b>, <b>702</b>, <b>902</b>, <b>1402</b> or <b>1602</b>) causes, if, as a result of the execution of an instruction to alter the content of a register (<b>125</b>, <b>742</b>, <b>931</b>, <b>932</b>, <b>1429</b> or <b>1629</b>) prior to a series of instructions to be executed reiteratively, the content of the register (<b>125</b>, <b>742</b>, <b>931</b>, <b>932</b>, <b>1429</b> or <b>1629</b>) satisfies a specific condition, a second instruction storing means (<b>104</b>, <b>704</b>, <b>904</b>, <b>1421</b> or <b>1621</b>) to hold the series of instructions to be executed reiteratively and causes them to be outputted reiteratively from the second instruction storing means (<b>104</b>, <b>704</b>, <b>904</b>, <b>1421</b> or <b>1621</b>) (see FIGS. 1, <b>5</b>, <b>7</b>, <b>11</b> and <b>13</b>).</p><p>Further, the final one of the series of instructions to be executed reiteratively in the data processing apparatus (<b>100</b>, <b>700</b>, <b>1400</b>, <b>1600</b>) is an instruction to cause branching to the first one of the series of instructions to be effected when a prescribed condition has come to be satisfied.</p><p>Further, the instruction to alter the content of the register (<b>125</b>, <b>1429</b> or <b>1629</b>) in the data processing apparatus (<b>100</b>, <b>700</b>, <b>1400</b> or <b>1600</b>) is an instruction to designate the logical value of a specific bit (<b>124</b>, <b>1428</b> or <b>1628</b>) contained in the register (<b>125</b>, <b>1429</b> or <b>1629</b>) (see FIGS. 1, <b>11</b> and <b>13</b>).</p><p>Further, in the data processing apparatus (<b>700</b>), the instruction to alter the content of the register (<b>125</b>, <b>1429</b> or <b>1629</b>) is an instruction to load the number of times the execution of the series of instructions is to be repeated into the register (<b>742</b>) (see FIG. <b>5</b>).</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b> or <b>900</b>), the second instruction storing means is a different instruction buffer (<b>104</b>, <b>704</b> or <b>904</b>) from instruction queues to store a plurality of instructions to be read out of the first instruction storing means prior to execution.</p><p>Further, in the data processing apparatus (<b>900</b>), the instruction to alter the content of the register (<b>931</b> or <b>932</b>) is an instruction to load information to specify the position of the leading one and information to specify the position of the trailing one of the series of instructions to be repeated into the register (<b>931</b> or <b>932</b>) (see FIG. 7)</p><p>Further, in the data processing apparatus (<b>900</b>), that the number of the instructions to be executed reiteratively, obtained from the information to specify the position of the leading instruction and the information to specify the position of the trailing information, is not greater than a specific value corresponds to the aforementioned specific condition (see FIG. <b>7</b>).</p><p>Further, in the data processing apparatus (<b>1400</b> or <b>1600</b>), the second instruction storing means is instruction queues (<b>1421</b> or <b>1621</b>) to store a plurality of instructions to be read out of the first instruction storing means prior to execution.</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b>, <b>900</b>), the second instruction storing means (<b>104</b>, <b>704</b> or <b>904</b>) has a memory holding circuit (<b>1030</b>_k_l) whose constituent elements include a first N channel type MOSFET (<b>1103</b>) of which the gate terminal is connected to a first node (WL-k), either one of the source and drain terminals is connected to a second node (BL-l) and the other to a third node (N<b>1101</b>); a second N channel type MOSFET (<b>1104</b>) of which the gate terminal is connected to the first node (WL-k), either one of the source and drain terminals is connected to a fourth node (BLB-l) and the other to a fifth node (N<b>1102</b>); a third N channel type MOSFET (<b>1101</b>) of which the gate terminal is connected to a fifth node (N<b>1102</b>), the drain terminal is connected to the third node (N<b>1101</b>) and the source terminal is connected to a first operating potential point (GND); and a fourth N channel type MOSFET (<b>1102</b>) of which the gate terminal is connected to the third node (N<b>1101</b>), the drain terminal is connected to the fifth node (N<b>1102</b>) and the source terminal is connected to the first operating potential point (GND) (see FIGS. 1, <b>5</b>, <b>7</b>, <b>8</b> and <b>9</b>).</p><p>Further, in the data processing apparatus (<b>100</b>, <b>700</b> or <b>900</b>), the second instruction storing means (<b>104</b>, <b>704</b> or <b>904</b>) has an amplifying circuit (<b>1040</b>_l) responsive to input signals pairing the second node (BL_l) and the fourth node (BLB_l) (see FIGS. 1, <b>5</b>, <b>7</b> and <b>8</b>).</p><p>Further in a state in which the content of the register (<b>1429</b> or <b>1629</b>) does not satisfy the specific condition in the data processing apparatus (<b>1400</b> or <b>1600</b>), any instruction read out of the first instruction storing means (<b>1402</b> or <b>1602</b>) is temporarily held by the second instruction storing means (<b>1421</b> or <b>1621</b>) at most until it is executed once (see FIGS. <b>11</b> and <b>13</b>).</p><p>For instance, the data processing apparatus (<b>100</b>), in order to read out an instruction reiteratively from a buffer (<b>104</b>) in executing a loop, has only to insert an instruction to set a specific bit (<b>124</b>, a buffer control flag) immediately before the execution of the bit. Therefore, it can reduce the power consumed for memory accessing by reiteratively reading the instruction out of the small scale buffer (<b>104</b>) when processing the loop without using a repeat instruction.</p><p>Further, unless the specific bit (<b>124</b>, the buffer control flag) is set, the buffer (<b>104</b>) is not accessed in the processing of any loop. Therefore, in order to forbid the application of the control to read an instruction out of the buffer (<b>104</b>) reiteratively in executing a loop, it is sufficient merely to refrain from inserting an instruction to set the specific bit (<b>124</b>, the buffer control flag) immediately before the execution of the loop.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF DRAWINGS</h4><p>FIG. 1 illustrates the configuration of a data processing apparatus representing a first embodiment of the present invention (Embodiment 1).</p><p>FIG. <b>2</b>(<i>a</i>) and FIG. <b>2</b>(<i>b</i>) illustrate the instruction reading operation of the data processing apparatus of Embodiment 1.</p><p>FIG. 3 illustrates an algorithm for inserting a buffer control flag setting instruction into a program description in the data processing apparatus of Embodiment 1.</p><p>FIG. 4 illustrates a loop size distribution in the execution of a voice encoding/decoding program in a certain data processing apparatus.</p><p>FIG. 5 illustrates the configuration of a data processing apparatus representing a second embodiment of the invention (Embodiment 2).</p><p>FIG. 6 illustrates an algorithm for substituting an instruction in a program distribution in the data processing apparatus of Embodiment 2.</p><p>FIG. 7 illustrates the configuration of a data processing apparatus representing a third embodiment of the invention.</p><p>FIG. 8 illustrates the configuration of a buffer included in the data processing apparatus of Embodiment 1.</p><p>FIG. 9 illustrates the configuration of a memory cell included in the buffer.</p><p>FIG. 10 compares areas occupied by a buffer.</p><p>FIG. 11 illustrates the configuration of a data processing apparatus representing a fourth embodiment of the invention (Embodiment 4).</p><p>FIG. 12 illustrates control by the data processing apparatus of Embodiment 4.</p><p>FIG. 13 illustrates the configuration of a data processing apparatus representing a fifth embodiment of the invention (Embodiment 5).</p><p>FIG. 14 illustrates control by the data processing apparatus of Embodiment 5.</p><p>FIG. 15 illustrates a classification of the modes of carrying out the invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>BEST MODES FOR CARRYING OUT THE INVENTION</h4><p>Embodiments of the present invention will be described in detail below with reference to drawings.</p><h4>Embodiment 1</h4><p>FIG. 1 illustrates the configuration of a data processing apparatus representing a first embodiment of the invention. A data processing apparatus <b>100</b> consists of a data processing section comprising a control section <b>120</b>, an instruction executing section <b>140</b>, a program counter <b>160</b>, a buffer <b>104</b>, a selector <b>106</b> and the like, and of a memory <b>102</b>. The data processing apparatus <b>100</b> may either be formed over a single semiconductor substrate or only the aforementioned data processing section may be formed over a single semiconductor substrate. The control section <b>120</b> consists of an instruction decoder <b>122</b>, a control register <b>125</b>, a buffer control circuit <b>126</b> and the like. To add, instruction fetch queues(instruction pre-reading buffers) may as well be provided either within the instruction decoder <b>122</b> or between the selector <b>106</b> and the instruction decoder <b>122</b>.</p><p>The memory <b>102</b> is, for example, either a read only memory (ROM) or random access memory (RAM) as a main storage or a cache memory for holding some of the instructions to be stored into the main storage. The ROM may consist of, for instance, either a mask ROM programmed in a semiconductor manufacturing process or an electrically rewritable non-volatile memory such as a flash memory. The RAM may consist of, for instance, a static random access memory (SRAM), a dynamic random access memory (DRAM), or a ferroelectric memory (an electrically rewritable nonvolatile whose write cycle and read cycle are substantially equal). The cache memory may be composed in a full associative or a set associative system.</p><p>Incidentally, the output S<b>162</b> of the program counter <b>160</b> may be supplied to the memory <b>102</b> via an address bus.</p><p>In this embodiment, control to read instructions reiteratively out of the buffer <b>104</b> when a loop, wherein the trailing one of a group of instructions to be executed reiteratively constitutes a conditional branching instruction to the leading instruction. Therefore it utilizes no repeat instruction. An outline of the operation of the data processing apparatus <b>100</b> to execute a group of instructions reiteratively will be presented below.</p><p>(1) Immediately before the execution of a loop to which control to read instructions reiteratively out of the buffer <b>104</b>, an instruction to set a specific bit <b>124</b> (buffer control flag) is executed. From immediately after the setting of the specific bit <b>124</b> (buffer control flag) onward, the instructions read out of the memory <b>102</b> are successively written into the buffer <b>104</b> while being put to execution. The process goes on to (2).</p><p>(2) After the bit <b>124</b> (buffer control flag) is set, the conditional branching instruction (trailing instruction) is first read, and the process goes on to (3) if that condition is satisfied, or to (5) if it is not satisfied.</p><p>(3) Accessing to the memory <b>102</b> is stopped, and the instructions stored in the buffer <b>104</b> are read successively, beginning with the leading one. The process goes on to (4).</p><p>(4) The conditional branching instruction (trailing instruction) is read, and the process goes on to (3) if that condition is satisfied, or to (5) if it is not satisfied.</p><p>(5) Accessing to the memory <b>102</b> is stopped, and usual reading of instructions out of the memory <b>102</b> is started. The bit <b>124</b> (buffer control flag) is cleared.</p><p>By the process described above, no repeat instruction is used, but instructions are read reiteratively out of the small buffer <b>104</b> and the memory <b>102</b> is prevented from being accessed during loop processing. Further, unless the bit <b>124</b> (buffer control flag) is set, no accessing to the buffer <b>104</b> takes place during the processing of any loop. Therefore, in order to forbid the application of control to read instructions reiteratively out of the buffer <b>104</b> when a given loop is to be executed, it is sufficient merely to refrain from inserting an instruction to set the bit <b>124</b> (buffer control flag) immediately before the execution of the loop.</p><p>Next will be presented an example of loop in which the trailing one of a group of instructions to be executed reiteratively constitutes a conditional branching instruction to the leading instruction.</p><p>In order, for example, to execute n (n is a positive integer) instructions (inst(<b>1</b>), inst(<b>2</b>), . . . , inst(n)) m times (m is a positive integer), the program is encoded as follows.</p><p>gr<b>0</b>\u2190km;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>Here \u201cgr<b>0</b>\u2190m\u201d denotes the setting of the number of loop repeats into a register (gr<b>0</b>, provided in the instruction executing section for example). \u201cgr<b>0</b>\u2190gr<b>0</b>\u22121\u201d denotes a decrement of the number of loop repeats. \u201cif NZ goto LOOP\u201d is a conditional branching instruction to cause branching to the leading instruction (inst(<b>1</b>)) of the loop if the result of calculating the decrement of the number of loop repeats, performed immediately before, is not 0 (NZ: Not Zero), i.e. the loop has not yet been completed.</p><p>When this loop is executed, the buffer <b>104</b> is caused to hold the instructions, and to have the instructions reiteratively read out of this buffer <b>104</b>, an instruction (set BCF) to set the buffer control flag <b>124</b> (BCF) in the control register <b>125</b> is inserted before the leading instruction (inst(<b>1</b>)) of the loop as follows.</p><p>gr<b>0</b>\u2190m;</p><p>set BCF;</p><p>LOOP: inst(<b>1</b>);</p><p>inst(<b>2</b>);</p><p>.</p><p>.</p><p>.</p><p>inst(n);</p><p>gr<b>0</b>\u2190gr<b>0</b>\u22121;</p><p>if NZ goto LOOP;</p><p>FIG. 2 illustrates the operation to read instructions which takes place when the data processing apparatus <b>100</b> processes the above-described loop. The operation of the data processing apparatus <b>100</b> will be described below with reference to FIG. <b>2</b>.</p><p>The instruction reading operation of the data processing apparatus <b>100</b> has the following three states of operation (see FIG. <b>2</b>(<i>b</i>)).</p><p>(1) \u201cUsual\u201d State</p><p>An instruction read out of the memory <b>102</b> in accordance with the count of the program counter <b>160</b> is delivered as it is to the control section <b>120</b> via the output S<b>101</b> of the memory and a bus S<b>102</b>. The buffer <b>104</b> is at halt. The selector <b>106</b> is caused by a selection signal SEL to select a signal of an output S<b>103</b> from the bus S<b>102</b>.</p><p>(2) State of \u201cWriting Into Buffer\u201d</p><p>The instruction read out of the memory <b>102</b> is successively written into the buffer <b>104</b> at the same time as being delivered to the control section <b>120</b>. The selector <b>106</b> is caused by the selection signal SEL to select the signal of the output S<b>103</b> from the bus S<b>102</b>.</p><p>(3) State of \u201cReading Out of Buffer\u201d</p><p>The instruction read out of the memory <b>102</b> is delivered to the control section <b>120</b>. The buffer <b>104</b> is at halt. The selector <b>106</b> is caused by the selection signal SEL to select a signal of an output S<b>104</b> from the buffer <b>104</b>.</p><p>As illustrated in FIG. <b>2</b>(<i>a</i>), when the buffer control flag <b>124</b> (BCF) is not set, the data processing apparatus <b>100</b> reads instruction in the \u201cusual\u201d state. Once an instruction (set BCF) to set the buffer control flag <b>124</b> (BCF) is executed, instructions are read in accordance with the following rules.</p><p>(i) Immediately after the buffer control flag <b>124</b> (BCF) is set, a shift to the state of \u201cwriting into buffer\u201d takes place.</p><p>(ii) When the conditional branching instruction (if NZ goto LOOP) is read in the state of \u201cwriting into buffer,\u201d (iii) will be followed if the condition is satisfied, or (v) will be followed if it is not satisfied.</p><p>(iii) A shift to the state of \u201creading out of buffer\u201d takes place. Instructions stored in the buffer <b>104</b> are sequentially read beginning with the leading one. If the conditional branching instruction (if NZ goto LOOP) is read, (iv) will be followed.</p><p>(iv) If the condition is satisfied, (iii) will be followed, or if not, (v) will be followed.</p><p>(v) A shift to the \u201cusual\u201d state takes place. The buffer control flag <b>124</b> (BCF) is cleared by a buffer control clear signal CLR.</p><p>In order to perform the actions of (i) through (v), the buffer control circuit <b>126</b> issues the following control signals to the memory <b>102</b>, buffer <b>104</b>, selector <b>106</b> and buffer control flag <b>124</b> (BCF) on the basis of an output S<b>126</b> from the buffer control flag <b>124</b> (BCF) and branching information S<b>123</b> (information concerning the detection of a conditional branching instruction and on the satisfaction or non-satisfaction of the condition) from the instruction decoder <b>122</b>.</p><p>(a) Memory Enable Signal MEN:</p><p>This signal causes the memory <b>102</b> to be instructed to operate or stop. When at a \u201cLOW\u201d level, the signal causes the memory <b>102</b> to stop in the state of \u201creading out of buffer.\u201d When at a \u201cHIGH\u201d level, it causes the memory <b>102</b> to operate. This signal may as well be used as a memory access request signal.</p><p>(b) Selector Control Signal SEL:</p><p>This signal causes the selector <b>106</b> to be controlled. When at a \u201cHIGH\u201d level, it causes the output S<b>104</b> from the buffer to be selected in the state of \u201creading out of buffer.\u201d When at a \u201cLOW\u201d level, it causes the output S<b>103</b> from the bus <b>102</b> to be selected.</p><p>(c) Pointer Reset Signal RST:</p><p>This signal causes the pointer of the buffer <b>104</b> to be returned to the start position. It is caused to be activated (\u201cHIGH\u201d level) when the conditional branching instruction is read in either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer.\u201d</p><p>(d) Buffer Enable Signal BEN:</p><p>This signal causes the buffer <b>104</b> to be instructed to operate or stop. In either the state of \u201cwriting into buffer\u201d or the state of \u201creading out of buffer,\u201d it is turned \u201cHIGH\u201d and causes the buffer <b>104</b> to be operated.</p><p>(e) Write Enable Signal WEN:</p><p>This signal causes an instruction to be given to write into or read out of the buffer <b>104</b>. In the state of \u201cwriting into buffer,\u201d it is turned \u201cHIGH\u201d and caused to instruct writing.</p><p>(f) Buffer Control Flag Clear Signal CLR:</p><p>When the condition of the conditional branching instruction is not satisfied, this signal is caused to clear the buffer control flag <b>124</b> (BCF).</p><p>Thus, this embodiment can reduce the power consumed for memory accessing by reiteratively reading instructions out of the small scale buffer <b>104</b> when processing a loop without using a repeat instruction. To add, the buffer control circuit <b>126</b> can be realized with a very small scale sequential circuit.</p><p>In this embodiment, unless the buffer control flag <b>124</b> (BCF) is set, no accessing to the buffer <b>104</b> takes place during the processing of any loop. Therefore, in order to forbid the application of control to read instructions reiteratively out of the buffer <b>104</b> when a given loop is to be executed, it is sufficient merely to refrain from inserting an instruction to set (set BCF) the bit <b>124</b> (buffer control flag) immediately before the execution of the loop (immediately before inst(<b>1</b>) in the above-cited example).</p><p>Next, in order to apply control to read instructions reiteratively out of the buffer <b>104</b> to only small scale loops which involve no flow control instructions, such as a branching instruction, except the trailing instruction (hereinafter referred to as \u201csimple reiterative loops\u201d) and whose number of constituent instructions is not greater than the maximum number of instructions the buffer <b>104</b> can accommodate, a buffer control flag set instruction (set BCF) is inserted into the program description in accordance with an algorithm shown in FIG. <b>3</b>. The algorithm shown in FIG. 3 will be explained below.</p><p>(1) One instruction is referred to (S<b>1</b>).</p><p>(2) If the instruction satisfies all of the following conditions A through D, processing under (3) is performed. In any other case, (4) is followed (S<b>21</b>, S<b>22</b>, S<b>23</b>, S<b>24</b>).</p><p>Condition A: The instruction referred to is a conditional branching instruction (if NZ goto loop in the example cited above).</p><p>Condition B: (Address of branching destination)&lt;(Address of conditional branching instruction).</p><p>Condition C: (Number of instructions from instruction on branching destination to conditional branching instruction)\u2266(Maximum number of instructions buffer <b>104</b> can accommodate), n+2\u2266(Maximum number of instructions buffer <b>104</b> can accommodate) in the above-cited example.</p><p>Condition D: Between the instruction on the branching destination and the conditional branching instruction (from inst(<b>1</b>) to if NZ goto LOOP in the above-cited example), there is no 