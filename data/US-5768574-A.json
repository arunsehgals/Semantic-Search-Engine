rnal cache unit 102 and/or main memory 104. Internal cache unit 108 stores instruction and data information for use by fetch unit 110 and execution unit 112. In one embodiment, internal cache unit 108 includes a unified instruction and data cache. In another embodiment, separate instruction and data caches are configured into internal cache unit 108.</p><p>Before discussing the unique features of the present invention, the units of microprocessor 101 will be described. Fetch unit 110 fetches instructions from internal cache unit 108 and passes the instructions to instruction decode unit 114. Instruction decode unit 114 decodes the received instructions for dispatch to execution unit 112. Operands which reside in registers are fetched by instruction decode unit 114 and provided with the instruction when the instruction is dispatched to execution unit 112. Execution unit 112 is configured to execute instructions once the operands are available. As will be appreciated by those skilled in the art, x86 instructions sometimes have operands which are stored in memory at an address specified in a register, by an offset, or by some combination of registers and offsets. In order to retrieve operands stored in memory, execution unit 112 passes segment register identification information and a calculated offset to address translation unit 116. Segment register identification information is generated from either segment override prefix bytes or from the default segment register for the associated instruction. Based on the translation mode of microprocessor 101, address translation unit 116 translates the address via the segmentation method and optionally via the paging method described above.</p><p>In one embodiment, the translated address is passed by address translation unit 116 to the internal cache unit. In other embodiments, a cache access is started by execution unit 112 and completed using the translated address from address translation unit 116. In still another embodiment, internal cache unit 108 is addressed with an untranslated address. In this embodiment, address translation unit 116 is accessed when a cache miss occurs, or when cache lines are removed from internal cache unit 108 and returned to main memory 104.</p><p>Generally speaking, address translation unit 116 is configured to receive segment register identification information and an offset and to translate this information into a physical address. If flat addressing mode is in effect, the segment register identification information is unimportant since the segment registers each contain the same value. Therefore, features may be added to microprocessor 101 by interpreting the segment identification information passed to address translation unit 116. Features added in this way may be transparent, such that code written to take advantage of the features will run correctly on processors which implement the x86 architecture but do not implement the added features and such that code which was written without awareness of the features will run correctly on processors which implement the added features. Features added in this way may also be non-transparent, such that code written to take advantage of the features may not run correctly on processors which do not implement the features and such that code written without awareness of the features may not run on processors which implement the features. Additionally, features may be added in a non-transparent fashion by using the value stored within the selected segment register (i.e. the segment register specified by the segment register override prefix) to control a feature. When the value stored is used, the feature is non-transparent because address translation unit 114 is configured to ignore (when performing translations) the portion of the segment register used to control the feature. Since this functionality is not a part of the 80\u00d786 architecture, the adding of features controlled by the values stored in a segment register is non-transparent. Many different features are contemplated, as will be revealed below after a discussion of address translation unit 116 in more detail.</p><p>FIG. 2 shows address translation unit 116 of FIG. 1 in more detail for the case of real mode physical address generation. In this mode, address translation unit 116 generates 20-bit physical addresses. Address translation unit 116 is presented with segment register identification information and a 16-bit offset value. Multiplexor 204 uses the segment register selection information to provide the contents of one of the segment registers to the shift register 206. (8086/8 microprocessors have only four of the six segment registers shown: CS, DS, ES, and SS). Shift register 206 then shifts this value four binary bit positions to the left, forming the 20-bit base address of a memory segment. Adder 208 adds the 16-bit offset to the 20-bit segment base address, resulting in a 20-bit physical address for a location in memory.</p><p>FIG. 3 shows address translation unit 116 of FIG. 1 in more detail for the case of protected mode physical address generation. Protected mode is not available on 8086/8 microprocessors. As in real mode, address translation unit 116 is presented with segment register identification information and an offset value. In protected mode, however, the segment register contains an index into one of two tables of memory segment information residing in main memory. The tables contain information about the translation of the address, including the base address of the segment and the size of the segment.</p><p>Beginning with the 80286 microprocessor, two general purpose segment registers were added (FS and GS), bringing the total number of segment registers to six. Information about six memory segments may be loaded into the six segment registers. Typically shadow registers associated with each segment register store the data from the associated segment descriptor, including the base addresses of the segment. In the 80286, segment base addresses are 24 bits long. In the 80386 and 80486, segment base addresses are 32 bits long. Multiplexor 304 uses the segment register identification information to provide the contents of one of the base addresses of the corresponding memory segment. Adder 306 adds the offset to the segment base address, resulting in a physical address for a location in memory (assuming paging circuitry 308 is disabled). In the 80286, offsets are 16 bits long, and physical addresses are 24 bits long. In the 80386 and 80486, offsets may be 16 or 32 bits long, and physical addresses are 32 bits long. If paging circuitry 308 is enabled, the address formed by adder 306 is translated yet again according to a paging algorithm. The paging algorithm uses high order bits of the address formed by adder 306 to index into a page directory containing addresses of page tables. The address of the page table is added to a second range of bits from adder 306 to find a particular page directory entry. The information stored therein is used to translate the address formed by adder 306 to a physical address.</p><p>In flat addressing mode, the paging algorithm is used for the translation and the address generated by adder 306 is the same as the logical address, as noted above. Therefore, the segment registers are of very little use. Of particularly little use are segment registers FS and GS, which are not default segment registers for x86 instructions. Therefore, the segment register override bytes referring to the FS and GS registers may be used to enable expanded features of microprocessor 101. Furthermore, segment register override bytes which specify the default segment register for an instruction may be used in another embodiment. It is noted that this other embodiment may also be used when flat memory addressing is not in effect.</p><p>FIG. 4 is a block diagram of a portion of microprocessor 101 including a cache control unit 404. Cache control unit 404 is configured within internal cache unit 108 and is coupled to execution unit 112 and to a control register 402. Cache control unit 404 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of an enabling bit 400 in control register 402. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108. This cacheability selection is in addition to the architectural cacheability selection of the x86 architecture as embodied in the PCD bit of the page table entry. In one embodiment, the data is stored unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register overrides for this function.</p><p>In another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The cacheability of a particular address is thereby determined by the value conveyed.</p><p>If enabling bit 400 is cleared, the segment register identification information is not used to determine cacheability of a particular address. In another embodiment, the cacheability trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>In yet another embodiment, cache controller 404 is configured to selectively store a line in write-through or writeback mode. When enabling bit 400 is set, the cache controller 404 selectively stores data associated with the instruction which produced the segment register identification information in internal cache unit 108 in a write-through or writeback mode. This mode selection is in addition to the architectural write-through selection of the x86 architecture as embodied in the PWT bit of the page table entry. In one embodiment, the data is stored in writeback mode unless the FS segment register is specified by a segment register override prefix byte for the associated instruction. Other embodiments may use other segment register override prefix bytes for this function. In yet another embodiment, the value stored within the selected segment register is conveyed to cache control unit 404. The write-through or writeback mode of a particular address is thereby determined by the value conveyed. If enabling bit 400 is cleared, the segment register identification information is not used to determine the write-through or writeback mode of a particular address. In another embodiment, the write-through or writeback trait for an address is conveyed to external cache 102 (shown in FIG. 1).</p><p>Cache control unit 404 has another embodiment which implements a cache flush or cache clean operation dependent on a particular value of segment register identification information associated with an instruction. A cache flush operation causes a cache line containing the address of the cache flush operation to be removed from the cache. If the line is modified with respect to main memory, the modified value is written back to main memory. A cache clean operation is similar to the flush operation in that a modified cache line is written back to main memory. However, the cache clean operation does not remove the line from the cache. These operations affect a single cache line, as opposed to the INVD and WBINVD instructions of the x86 architecture which affect the entire cache at once. The GS segment override prefix byte is used to cause a flush operation in this embodiment, and the ES segment override prefix byte is used to cause a clean operation. Other embodiments may use other segment register override prefix bytes for these functions, or may use the value stored in the selected segment register to specify these functions. If the value stored in the selected segment register is used, then the value is conveyed to cache control unit 404 along with the segment identification value.</p><p>In still another embodiment, cache control unit 404 implements a speculative miss line fill function based on the use of the FS segment register override prefix byte. In this embodiment, if the FS segment override prefix byte is specified for a particular instruction and the address associated with that instruction misses internal cache unit 108, then the cache line containing the address is fetched from main memory even if the instruction was executed by execution unit 112 speculatively. Sometimes, a particular instruction may appear to be speculative to microprocessor 101 even though the address is correct and will be needed by the program in the near future. If a programmer or compiler is aware of this situation, it could specify that a cache miss for the instruction be speculatively fetched into internal cache 108. When used in the context of instruction execution, the term \"speculative\" means that an instruction is executed before that instruction is know to be required by the sequential execution of instructions in a program.</p><p>Another embodiment of cache controller 404 is configured to allocate a cache line for a store instruction which misses internal cache 108 if the ES segment register override prefix byte is included in the store instruction. If enabling bit 400 is not set, then store instructions which miss internal cache 108 are written to main memory without fetching the associated cache line into internal cache 108. If enabling bit 400 is set, then store instructions that miss internal cache 108 will cause a cache line fill of the associated data bytes to occur if the store instruction includes the ES segment register override prefix byte. If the ES segment register override prefix byte is not included, then the cache line fill will not occur and the store data will be written to main memory. In still a further embodiment, a store instruction which misses the cache will cause a cache line to be allocated but the associated data bytes will not be fetched from memory. The data bytes provided by the store instruction will be stored into the cache line. However, the other data bytes of the cache line are marked invalid in internal cache 108 until additional store instructions cause the other data bytes to become valid. In an alternative embodiment, the other data bytes are set to zero. An additional embodiment of cache control unit 404 is configured to used the value stored in the selected segment register to specify the above mentioned speculative miss line fill functions.</p><p>In one embodiment, control register 402 is control register 0 present in 80386 and later microprocessors. The enabling bit 400 is bit 31 of control register 0, the paging bit. When bit 31 is set, paging is enabled.</p><p>FIG. 5 is a block diagram of a portion of microprocessor 101 including a data prefetch unit 500. Data prefetch unit 500 is coupled to execution unit 112 and to control register 402. Data prefetch unit 500 is selectively enabled using segment register identification information, provided by the execution unit 112, and using the contents of enabling bit 400 in control register 402. When enabling bit 400 is set, data prefetch unit 500 prefetches data associated with cache lines stored in consecutive groups of bytes of main memory 104 (shown in FIG. 1) starting at the address indicated by the instruction. The cache lines are stored by internal cache unit 108. If enabling bit 400 is not set, then the data prefetch unit remains idle. In one embodiment, data prefetch unit 500 begins prefetching if the FS segment register override is used for an instruction. The number of consecutive cache lines fetched by data prefetch unit 500 may vary from embodiment to embodiment. In another embodiment, data prefetching begins under the control of the value stored in the selected segment register. Additionally, the number of consecutive cache lines to fetch may be specified by the value stored in the selected segment register.</p><p>In yet another embodiment, data prefetch unit 500 implements other prefetching schemes. It is noted that many prefetching schemes are suitable for data prefetch unit 500, including a stride based prefetching scheme and other \"smart\" prefetching schemes. Various \"smart\" prefetching schemes are well-known.</p><p>FIG. 6 is a block diagram of a portion of microprocessor 101 including a branch prediction unit 600 which is including in fetch unit 110. Branch prediction unit 600 is coupled to execution unit 112 and to a control register 402. Branch prediction unit 600 implements the branch prediction scheme embodied within fetch unit 110, as well as an alternative scheme. The alternative scheme is enabled through segment register identification information, provided by execution unit 112, and the contents of enabling bit 400 in control register 402. If enabling bit 400 is not set, then the branch prediction scheme of branch prediction unit 600 is used. If enabling bit 400 is set, then the branch prediction scheme of branch prediction unit 600 is used except in the case that a noop instruction immediately prior to the branch instruction includes the FS or GS segment register override prefix bytes. In this case, the alternative branch prediction scheme is used.</p><p>In one embodiment, the alternative branch prediction scheme is to predict the branch taken if a prior noop includes the FS segment register override prefix byte, or to predict the branch not taken if the GS segment register override prefix byte is included. In the context of this application, the term \"noop\" does not refer to the NOP instruction of the x86 architecture. Instead, a \"noop\" is an instruction which does not change a register or memory, but does reference a memory location so that a segment register override prefix byte may be included with the instruction. An exemplary noop instruction would be an instruction which adds zero to the contents of a memory location. Additionally, the value stored in the selected segment register may be used to enable or disable the alternative branch prediction scheme.</p><p>The abovementioned uses for the segment register identification information are transparent uses, except for the embodiments which use the value stored in the selected segment register (instead of the existence of a particular segment override prefix byte) to control a feature. Non-transparent uses are also contemplated, as described below.</p><p>Two exemplary non-transparent uses may be implemented within execution unit 112. First, a segment register override byte may be used to create instructions which do not modify the condition flags. For example, the ADD instruction modifies the condition flags. An ADD instruction which uses a memory operand could be modified to an ADD instruction which does not modify the condition flags by using the segment register override prefix byte. In one embodiment, the FS segment register override prefix byte indicates that the ADD instruction will not modify the condition flags. This functionality allows for the scheduling of branches which are dependent on a condition flag generated by a particular operation. Numerous instructions may be executed between the branch instruction and the instruction it depends upon if the instructions do not modify the condition flags.</p><p>Another embodiment which aids the scheduling of branch instructions is to implement multiple sets of condition flags. In this manner, multiple sets of conditions may be maintained simultaneously. Segment register override prefix bytes may be used with instructions which modify the condition flags to indicate which of multiple sets of condition flags to modify. Noop instructions immediately prior to a branch instruction then use segment register override prefix bytes to indicate which of multiple sets of condition flags the branch instruction should use to determine the branch direction. If no segment register override prefix bytes are included with respect to an instruction, then a default set of condition flags are associated with the instruction. Another embodiment uses the value stored within the selected segment register to select the set of condition flags to be used by a particular instruction.</p><p>Another non-transparent use of segment register override prefix bytes may be embodied within instruction decode unit 114. As mentioned above, instruction decode unit 114 reads the register(s) specified as operands of an instruction and passes the values to execution unit 112 along with the instruction. In this embodiment, segment register override prefix bytes are used to select one of multiple register banks which store data. Each register bank includes the full complement of x86 registers. In this manner, the register set of the architecture may be expanded without changing the instruction encodings. As will be appreciated by those skilled in the art, a larger register set allows more operand values to be held in registers (which may be accessed quickly) and so accesses to memory (which typically require a longer period of time) are lessened. In one embodiment, no segment register override prefix byte specifies the first bank of registers, a segment register override prefix byte indicating the FS segment register specifies a second bank of registers, a segment register override prefix byte indicating the GS segment register specifies a third bank of registers, and a segment register override prefix byte indicating the ES segment register specifies a fourth bank of registers. In another embodiment, the value stored within the selected segment register is used to select the appropriate register bank from numerous register banks.</p><p>It is noted that many other non-transparent uses may be created for segment register override prefix bytes. The present invention contemplates transparent and non-transp