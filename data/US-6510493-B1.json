processing system having a multi-level cache memory hierarchy in which the present invention may be incorporated;</p><p>FIG. 2 is a block diagram of a cache memory in accordance with the present invention;</p><p>FIG. 3 is a detailed logical block diagram of cache memory <b>30</b> from FIG. 2, in accordance with a preferred embodiment of the present invention; and</p><p>FIG. 4 is a high-level flow diagram of an exemplary application of a preferred embodiment of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT</h4><p>The present invention may be implemented in any data processing system having a cache memory. Also, it should be understood that the features of the present invention may be applicable in various data processing systems having a multi-level cache memory hierarchy.</p><p>Referring now to the drawings and in particular to FIG. 1, there is illustrated a block diagram of a data processing system <b>10</b> having a multi-level cache memory hierarchy in which the present invention may be incorporated. Processor <b>23</b> is constructed as a monolithic integrated circuit device comprising a processing unit <b>11</b>, an on-chip instruction cache <b>12</b>, and an on-chip data cache <b>13</b>. Both caches <b>12</b>, <b>13</b> are primary caches and are connected to processing unit <b>11</b> by paths within a local bus structure. As shown, instruction cache <b>12</b> is coupled to processing unit <b>11</b> via a local bus <b>15</b> and a cache controller <b>17</b>, while data cache <b>13</b> is coupled to processing unit <b>11</b> via local bus <b>15</b> and a cache controller <b>18</b>.</p><p>A secondary cache <b>14</b> is coupled to processing unit <b>11</b> via local bus <b>15</b> and a cache controller <b>19</b>. Secondary cache <b>14</b> is typically much larger than either instruction cache <b>12</b> or data cache <b>13</b>, and access to secondary cache <b>14</b> is somewhat slower than to either instruction cache <b>12</b> or data cache <b>13</b>. Processing unit <b>11</b> is connected to a system bus <b>20</b> via a bus interface <b>16</b> in which timing and control translations between local bus <b>15</b> and system bus <b>20</b> take place. A main memory <b>21</b> and a disk storage device <b>22</b> are also coupled to system bus <b>20</b>.</p><p>As depicted in FIG. 1, the memory hierarchy is organized from the fastest to the slowest, from the smallest to the largest, and from the most expensive per bit to the least expensive per bit, in progression from primary caches <b>12</b>, <b>13</b> to secondary cache <b>14</b>, to main memory <b>21</b>, and to disk storage device <b>22</b>. Typically, main memory <b>21</b> contains a subset of what is in disk storage device <b>22</b>, and secondary cache <b>14</b> contains a subset of what is in main memory <b>21</b>.</p><p>Depending on the relationship between primary caches <b>13</b>, <b>14</b> and secondary cache <b>16</b>, each of primary caches <b>13</b>, <b>14</b> may contain information independent of what is in secondary cache <b>14</b> (i.e., primary caches may not enforce strong inclusivity).</p><p>Processing unit <b>11</b> can access primary caches <b>12</b>, <b>13</b> within a single processor cycle, while it may take several processor cycles to access secondary cache <b>14</b>. If a cache \u201cmiss\u201d occurs in primary caches <b>12</b>, <b>13</b> and secondary cache <b>14</b>, then main memory <b>21</b> is accessed to perform a cache allocation (or linefill operation), which entails replacing a cache line with a group of data from main memory <b>21</b> that contains the information requested by processing unit <b>11</b>. This cache allocation must be performed in order to satisfy the attempted cache access for which a cache \u201cmiss\u201d occurred. If main memory <b>21</b> does not contain the information for which the cache allocation is attempted, then a page containing this data is obtained from disk storage device <b>22</b> such that the cache allocation can be completed.</p><p>As mentioned previously, there is not a single cache replacement algorithm that can provide optimal results for all application software. This is because each application software has a different data demand requirement from the others. Thus, optimal results can only be achieved if application software can inform the cache memory as to what information should be replaced quickly, and what information should be replaced slowly. This lifetime requirement of an instruction within a software application can be included with page information in a translation lookaside buffer (TLB), or with compiler hints within the instruction.</p><p>In light of the above, the present invention provides an improved method of managing the replacement of cache entries, which allows certain instruction or data to have a longer temporal locality than others at any time, while still providing a gradual fair replacement of the cache lines within the entire cache memory.</p><p>With reference now to FIG. 2, there is depicted a block diagram of a cache memory in accordance with the present invention. This cache memory is preferably a primary cache memory such as instruction cache <b>12</b> and data cache <b>13</b> from FIG. <b>1</b>. As shown, a cache memory <b>30</b> includes a directory <b>31</b> for storing address tags and a cache entry array <b>32</b> for storing instructions (or data). Directory <b>31</b> also contains state bits and inclusivity bits (not shown) as they are known to those skilled in the art. Thus, each cache line within cache memory <b>30</b> includes an address tag and its associated data. Furthermore, cache memory <b>30</b> is divided into two partitions, namely, a first partition <b>33</b> and a second partition <b>34</b>. It is preferred to have an unequal number of cache lines between first partition <b>33</b> and second partition <b>34</b>. In the present embodiment, first partition <b>33</b> contains eight cache lines and second partition <b>34</b> contains <b>128</b> cache lines, though any number of cache lines is acceptable in each partition.</p><p>Cache memory <b>30</b> is preferably a content-addressable memory (CAM). As shown, a CAM control block <b>38</b> is associated with first partition <b>33</b>, and a CAM control block <b>39</b> is associated with second partition <b>34</b>.</p><p>In addition to directory <b>31</b> and cache entry array <b>32</b>, a replacement logic block <b>35</b> provides the necessary logic to allocate a cache line within cache memory <b>30</b>. Replacement logic block <b>35</b> is controlled by an allocation input <b>36</b> and a selection input <b>37</b>. Preferably, allocation input <b>36</b> is inactive during a normal cache access cycle (such as a read or write cycle), and is active when a cache line needs to be replaced. Selection input <b>37</b> is a software controllable signal input through which a cache line from one of the two partitions can be selected for allocation. For example, during an allocation cycle (i.e., when allocation input <b>36</b> is active), a cache line from first partition <b>33</b> is selected for allocation when selection input <b>37</b> is asserted, and a cache line from second partition <b>34</b> is selected for allocation when selection input <b>37</b> is not asserted.</p><p>In the present embodiment, any instruction (or data) that require a longer temporal locality will preferably be stored in first partition <b>33</b> while other data will be stored in second partition <b>34</b>. The cache replacement algorithm utilized in first partition <b>33</b> can be identical or different from the cache replacement algorithm utilized in second partition <b>34</b>. For example, first partition <b>33</b> and second partition <b>34</b> can both utilize a least-recently used (LRU) replacement algorithm; or as another example, first partition <b>33</b> utilizes the LRU replacement while second partition <b>34</b> utilizes a first-in-first-out (FIFO) algorithm.</p><p>Referring now to FIG. 3, there is illustrated a detailed logical block diagram of cache memory <b>30</b> from FIG. 2, in accordance with a preferred embodiment of the present invention. As shown, a replacement logic <b>47</b> for first partition <b>33</b> (from FIG. 2) is coupled to eight three-input AND gates <b>41</b>, a CAM control block <b>38</b> for first partition <b>33</b> is coupled to eight two-input AND gates <b>42</b>, a replacement logic <b>48</b> for second partition <b>34</b> (from FIG. 2) is coupled to 128 three-input AND gates <b>43</b>, and a CAM control block <b>39</b> for second partition <b>34</b> is coupled to 128 two-input AND gates <b>44</b>. Each of AND gates <b>41</b>, <b>42</b> is respectively coupled to directory <b>31</b> and cache entry array <b>32</b> via eight two-input OR gates <b>45</b>. Similarly, each of AND gates <b>43</b>, <b>44</b> is respectively coupled to directory <b>31</b> and cache entry array <b>32</b> via 128 two-input OR gate <b>46</b>. Replacement logic <b>47</b>-<b>48</b> and gates <b>41</b>-<b>46</b> are preferably part of replacement logic block <b>35</b> from FIG. <b>2</b>.</p><p>During a normal cache access cycle, a cache hit or cache miss is determined by comparing an address from memory management unit (MMU) <b>51</b> with the tag from directory <b>31</b> via a comparator <b>52</b>. Allocation input <b>36</b> is not asserted during the normal cache access cycle. During an allocation cycle after a cache miss, allocation input <b>36</b> is first asserted. Then, a cache line from first partition <b>33</b> will be selected for allocation if selection input <b>37</b> is asserted; otherwise, a cache line from second partition <b>34</b> is selected for allocation when selection input <b>37</b> is not asserted. Whether or not selection input <b>37</b> should be asserted during the allocation cycle is determined by a lifetime requirement of an instruction or data within a software application. As such, the assertion election of selection input <b>37</b> may be controlled by a software application. Once the election is made, replacement logic <b>47</b> is responsible for selecting a cache line from first partition <b>33</b> for replacement, and replacement logic <b>48</b> is responsible for selecting a cache line from second partition <b>34</b> for replacement. As mentioned previously, the replacement algorithm used within replacement logic for first partition <b>33</b> can be identical or different from the replacement algorithm used within replacement logic for second partition <b>34</b>.</p><p>The application of the present invention can be illustrated by way of a matrix multiplication example of multiplying matrix A=[a<sub>ij</sub>](0\u2267i\u2267n, 0\u2267j\u2267m) and matrix B=[b<sub>jk</sub>](0\u2267j\u2267m, <b>0\u2267k\u2267l)) to generate matrix C=[c</b><sub>ik</sub>](0\u2267i\u2267n, 0\u2267k\u2267l). With reference now to FIG. 4, there is illustrated a high-level flow diagram of an exemplary application of a preferred embodiment of the present invention. Starting at block <b>40</b>, a variable i is initialized to zero, as shown in block <b>41</b>. At this point, selection input <b>37</b> (from FIG. 3) is not asserted, and elements of the i<sup>th </sup>row of matrix A are loaded into second partition <b>34</b> (from FIG. 2) of the cache memory, as depicted in block <b>42</b>. Then, selection input <b>37</b> is asserted, and all elements of matrix B are loaded into first partition <b>33</b> (from FIG. 2) of the cache memory, as depicted in block <b>43</b>. Subsequently, the matrix multiplication is performed until i=n. In this example, the more \u201cpermanent\u201d data are loaded into the smaller section of the cache, and the other data are loaded into the larger section of the cache.</p><p>As has been described, the present invention provides a method and apparatus for managing cache line replacement within a cache memory. The present invention overcomes a prior art cache design problem of inadvertent premature removal of instruction (or data) from a cache memory during a cache line allocation. The present invention provides an enhanced cache line replacement process by allowing some critical by not frequently used data to be remain in the cache memory. While the additional control logic may complicate the cache memory construction (and requires extra silicon area), the benefits derived from the present invention generally outweigh such concerns, especially when the cost of additional circuitry diminishes with respect to the demand for higher processor performance.</p><p>While the invention has been particularly shown a