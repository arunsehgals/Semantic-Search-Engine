te the same cache block address are \"filtered out\" by not being passed to the associated BIAS. Remote processor stores, and local and remote channel stores are inputted and compared against address(es) in the filter memory . If not equal to any valid address, in the filter memory, the inputted address is recorded as a valid entry in the filter memory, and it is gated into BIAS. If equal to any valid address, the inputted address is not entered into the filter memory, and it is not gated to BIAS, so the no cache interrogation results.</p><p>U.S. Pat. No. 4,195,340, issued Mar. 25, 1980 to Joyce et al, and entitled \"First In First Out Activity Queue for a Cache Store\" discloses a FIFO buffer. FIG. 2 of Joyce shows the FIFO buffer as totally contained by a Replacement and Update unit. The FIFO buffer is shown as receiving data from three separate receivers, the three receivers shown as totally contained by a Bus Interface Unit.</p><h4>SUMMARY OF THE INVENTION</h4><p>This invention is an improved method and apparatus for the processing of invalidate requests. A queue for storing the invalidate requests is provided. The queue is divided into two parts, one part is contained within a cache controller to ensure that an invalidate request is immediately available for processing when the cache controller is otherwise idle. A second part is contained within a system interface to ensure that the system interface can detect and respond to more system transactions before the first invalidate request has been processed and to enable the system interface to be immediately aware if the entire queue is full.</p><p>A more detailed description of the invention will be facilitated by the drawings, which are described below.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of a typical multiprocessor computer system.</p><p>FIG. 2 is a block diagram of multiprocessor computer system of FIG. 1 with one of the processor modules shown in greater detail.</p><p>FIG. 3 is a block diagram of the multiprocessor computer system of FIG. 2 with a special purpose bus added.</p><p>FIG. 4 is a block diagram of the multiprocessor computer system of FIG. 3, with an invalidate queue added.</p><p>FIG. 5 is a block diagram of the multiprocessor computer system of FIG. 4, with the invalidate queue placed on a different component of the processor module.</p><p>FIG. 6 is a block diagram of the multiprocessor computer system of FIG. 5 with a second invalidate queue added.</p><p>FIG. 7 is a diagram of a single entry in the invalidate queue.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF THE INVENTION</h4><p>A typical multiprocessor computer system is shown in FIG. 1. Processor module 10 and other processor modules 10' are attached to a system bus 12, which is sometimes referred to as a \"memory bus\". Also attached to system bus 12 is main memory 14, input output (I/0) 52, and mass storage 54. Main memory 14, I/0 52, and mass storage 54 are shown as single blocks, but in a typical computer system, there will be several such devices. Also I/0 52 or mass storage 54 may be attached to system bus 12 by a separate bus (not shown).</p><p>FIG. 2 shows the system of FIG. 1, with processor module 10 shown in greater detail. Processor module 10 is connected to system bus 12 by the system interface 16. System interface 16 is attached to the module bus 18. Also connected to module bus 18 are the cache controller 22, the secondary cache rams 24, and the processor 20. Cache controller 22 is also connected directly to secondary cache rams 24.</p><p>As an item is brought into secondary cache rams 24, an entry is made in a table 42 on cache controller 22. Table 42 is a set of registers that contains, among other things, a pattern of bits indicating the main memory address of each of the items in the secondary cache rams 24, and a valid bit. Primary cache 44 is a part of the processor 20. The Content of primary cache 44 is a subset of the content of secondary cache rams 24. The main memory addresses of primary cache 44 are recorded in table 46, which is a set of registers that contains, among other things, a pattern of bits indicating the main memory address of each of the items in the primary cache 44 and a system settable valid/invalid bit.</p><p>System interface 16 monitors transactions that are broadcast on system bus 12. If system interface 16 detects a transaction requiring an invalidate request or a transaction indicating that another processor has requested information that may be in cache 44, it issues an invalidate request containing, among other information, the main memory address of the item to be invalidated. The invalidate request is transmitted from system interface 16 to cache controller 22 over the module bus 18. The cache controller 22 searches table 42 to determine if the main memory address of the item to be invalidated is present in the secondary cache rams 24. If cache controller 22 determines that the main memory address of the item to be invalidated is not present in cache rams 24, no further action is taken by either cache controller 22 or system interface 16. If cache controller 22 determines that the main memory address of the item to be invalidated is in secondary cache rams 24, cache controller 22 processes the invalidate request by changing the valid bit for the entry in table 42 to \"invalid\". Cache controller 22 then sends the invalidate request to processor 20. If the main memory address of the item to be invalidated is in table 46, the processor changes the valid indicator of the entry in table 46 to \"invalid\".</p><p>Content of primary cache 44 is a subset of content of secondary cache rams 24. Therefore, if the main memory address of the item to be invalidated is not present in table 42 on the cache controller, it cannot be in the table 46 on processor 20.</p><p>A further refinement of the invalidate filtering mechanism is shown in FIG. 3. It was noted above that the invalidate request was sent from system interface 16 to cache controller 22 over module bus 18, and that some invalidate requests result in no action. This transmission, over module bus 18, of invalidate requests which result in no action, can be eliminated by inserting private bus 26 between system interface 16 and cache controller 22. Private bus 26, unlike a system bus or a module bus carries transactions only from one system component to another, in this case the components being the cache controller 22 and the system interface 16. Additionally, private bus 26 can be designed to carry only certain types of transactions, such as invalidate requests and acknowledgments that a main memory address has been found in table 42.</p><p>Thus, if system interface 16 detects a transaction on system bus 12 that requires the issuance of an invalidate request, it issues the invalidate request directly to cache controller 22 over private bus 26. The cache controller 22 searches table 42 for the main memory address of the item to be invalidated, and proceeds as described in connection with FIG. 2. Note that, with the addition of private bus 26, only invalidate requests for main memory addresses that are present in table 42 generate any transactions on module bus 18; if processor 20 has no primary cache, invalidate requests do not need to be transmitted over the module bus at all.</p><p>Transmission of the invalidate request from system interface 16 to cache controller 22 typically involves sending a signal from one chip to another. This is very slow relative to communication within a single chip. In addition, other processor modules 10' or other systems elements may issue many transactions requiring invalidate requests. Therefore, system interface 16 may detect a second transaction on system bus 12 that requires the issuance of a second invalidate request before the first invalidate request has been transmitted or processed. Since system interface 16 has not completed transmitting the first invalidate request, it cannot accept the second invalidate request, and must request that the other processor modules 10' slow down or stop until it can process the invalidate request. This slows down system performance.</p><p>One method of avoiding this slowdown is by adding an invalidate request queue 30 as shown in FIG. 4. When system interface 16 detects a transaction requiring the issuance of a first invalidate request, it places the first invalidate request in first entry 32 of invalidate request queue 30. System interface 16 transmits a copy of the invalidate request in first entry 32 of invalidate queue 30 to cache controller 22 for processing. If a second transaction requiring an invalidate request is detected by system interface 16 before cache controller 22 has finished processing the first invalidate request, system interface 16 generates a second invalidate request and places the second invalidate request in second entry 34 of invalidate request queue 30. Subsequent invalidate requests are placed in the remaining entries in invalidate request queue 30. Only when the last entry 36 of queue 30 is filled does the system interface 16 need to request that the other processors slow down or stop. When cache controller 22 has completed processing the first invalidate request, system interface 16 moves the invalidate request in second entry 34 of invalidate request queue 30 to the first entry 32 of invalidate request and sends the new content of first entry 32 to cache controller for processing. Similarly, the remaining entries of invalidate request queue 30 are moved forward toward the front 38 of the invalidate request queue 30.</p><p>Processing of the invalidate requests takes place when cache controller 22 is otherwise idle. The invalidate request processing system operates most efficiently if an invalidate request is immediately available for processing whenever cache controller 22 is otherwise idle. However, moving the invalidate request from the queue 30 on system interface 16 to cache controller 22 may involve communication from chip to chip, which, as noted above, is slow relative to communication within one chip. Therefore, by the time cache controller 22 notifies system interface 16 that it is idle, and system interface 16 sends an invalidate request to cache controller 22, a request from processor 20 may have arrived at cache controller 22. The cache controller 22 would no longer be idle, and an opportunity to process an invalidate request would have been lost, resulting in a loss of system efficiency.</p><p>This loss of efficiency can be eliminated by placing invalidate queue 30 on cache controller 22, as shown in FIG. 5. First entry 32 of queue 30 is now immediately available to cache controller 22 for processing whenever cache controller 22 is idle.</p><p>Additional advantages can be attained by dividing the invalidate request queue into two sections, as illustrated in FIG. 6. First entry 32 of queue 30 is immediately available to cache controller 22 for processing whenever cache controller 22 is idle. Portion 50 of queue 30 on system interface 16 allows system interface 16 to be aware, without the need for chip to chip communication, if queue 30 is full, thereby requiring system interface 16 to request that other system components slow activity or stop. Additionally, having a portion 50 of queue 30 on system interface 16 allows system interface 16 to receive a new invalidate request while it is transferring a previous invalidate request from system interface 16 to cache controller 22.</p><p>Splitting of queue 30 also allows private bus 26 to be narrower, thereby using fewer of the input channels (\"pins\") of cache controller 22. Invalidate requests can be split into two portions by system interface 16. The two portions may be transmitted sequentially, and recombined in the cache controller 22. This is impractical without a queue on both system interface 16 and cache controller 22, since otherwise splitting the invalidate request would double the time necessary to transmit the invalidate request.</p><p>An important consideration is how many spaces should be available in the queue 30. There must be an adequate number of positions on the first portion 48 of queue 30 on cache controller 22 to minimize the instances in which cache controller 22 has to \"wait\" for an invalidate request. There must be an adequate number of positions on the second portion 50 of queue 30 on system interface 16 so that second portion 50 does not fill up while transferring invalidate requests to cache controller 22. The total number of positions in queue 30 must be adequate to ensure that queue 30 does not fill up, thereby slowing system performance. The maximum number of positions in each of sections 48 and 50 of queue 30 is a function of the space available on the chip on which the portion of the queue resides. The number of spaces is optimized by design considerations and the use of computer simulations. In the best mode known to the inventors, there are five positions of first portion 48 of queue 30 on cache controller 22, and there are sixteen positions on second portion 50 of queue 30 on system interface 16.</p><p>For clarity of explanation, the operation of invalidate request queue 30 has been described above as if the contents of entries are \"moved\" from one queue position to another as invalidate requests are processed. While this explains the logical operation of invalidate request queue 30, those skilled in the art will understand that queues are most commonly implemented as a set of registers, with two circular pointers. One of the two circular pointers points to the head of the queue, the other pointer points to the tail of the queue. As an entry in the queue is processed, the head of queue pointer moves to the next entry.</p><p>In the best mode known to the inventors, the two portions of the queue 30 are FIFO (first in - first out) structures implemented with a buffer at the input pins, and enough registers so that the buffer plus the number of registers is equal to the desired number of positions in the portion in the queue 30. Each of the two portions 48 and 50 of the queue 30 is implemented with two circulating pointers, one of which points to the register containing the head of the queue, and one pointer that points to the next register to be written to from the buffer. The use of circulating pointers in FIFO stacks is well known in the art.</p><p>The operation of the invalidate queue can be still better understood by reference to FIG. 7, which is a diagram of a single entry 36 in invalidate queue 30, and to FIG. 6. Single entry 36 comprises a register containing thirty one bit positions 58. Bit positions 58 are identified by number. In one common numbering scheme, the rightmost bit 60 is identified as bit zero, and the leftmost bit 62 is identified as bit thirty.</p><p>Address bits 64 (bit positions 5 through 30) contain the main memory address of the item to be invalidated.</p><p>Invalidate queue valid bit 60 (bit position 0) indicates whether table 42 has been searched for the address contained in address bits 64. When invalidate queue valid bit 60 is \"valid\", there is a valid entry in that position of invalidate queue 30. When cache controller 22 begins to search table 42 for the address contained in address bits 64, cache controller 22 changes invalidate queue valid bit to \"invalid\". If invalidate queue valid bit 60 of first entry 32 of queue 30 is \"invalid\", the queue is empty.</p><p>Flush bit 68 (bit position 1) is used to synchronize the processing of the invalidate request with the processing of other transactions in the computer. This synchronization method is described generally in U.S. patent application Ser. No. 07/212,416, filed Jun. 27, 1988 by Durdan, et al, entitled \"Method and Apparatus for Filtering Invalidate Requests\" and assigned to the assignee of the present application, and more specifically in U.S. patent application Ser. No. 07/591,199 (pending), filed Oct. 1, 1990, Callander et al, entitled \"A Two-Level Protocol for Multi-Component Bus Ownership, and Implement in a Multi-Processor Cache Write Back Protocol\" and assigned to the assignee of the current application.</p><p>Parity bits 70 (bit positions 2 and 3) are used for parity checking, which is well known in the art. Two parity bits are provided in order to allow for splitting the address bits 64 into two portions and transmitting the address bits 64 from the system interface 16 to the cache controller 22 in two cycles, as mentioned in the discussion of FIG. 4.</p><p>Invalidate command bit 72 (bit position 4) indicates whether the invalidate request resulted from a write request or a read request. The actions taken by the cache controller 16 or the processor 20 depends on the status of invalidate command bit 72, and on the status of the dirty and valid indicators in the entry in table 42 for address bits 64 .</p><p>If invalidate command bit 72 indicates that the invalidate command resulted from a read request, cache controller 16 examines table 42 to see if the address to be invalidated is \"clean\" or \"dirty\".</p><p>If the address is \"clean\", then, so far as that processor module 