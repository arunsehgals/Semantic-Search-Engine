bus also reduces system performance during I/O operations because the processor cannot access the L2 cache during an I/O operation. A further limitation of a look-aside L2 cache configuration is that it does not efficiently support cache line sizes larger than the L1 cache line size. In contrast, in-line L2 cache lines are frequently designed to be twice the length of L1 cache lines in order to reduce cache miss ratios by prefetching instructions and data based upon the statistical probability of data locality.</p><p>As should thus be apparent, it would be desirable to provide an improved method and system for implementing an optional look-aside L2 cache within a data processing system. In particular, it would be desirable to provide an improved cache system within a data processing system having a look-aside L2 cache configuration which support allocation on L2 write misses and which enable the prefetching of data and instructions.</p><h4>SUMMARY OF THE INVENTION</h4><p>It is therefore one object of the present invention to provide an improved data processing system.</p><p>It is another object of the present invention to provide an improved apparatus for managing data storage within a data processing system.</p><p>It is yet another object of the present invention to provide an improved memory controller within a data processing system having a look-aside cache architecture which caches stack operations and prefetches selected information for possible subsequent access by the processor.</p><p>The foregoing objects are achieved as is now described. An improved memory controller within a data processing system having a look-aside cache architecture is disclosed. The data processing system includes a processor having an upper level cache associated therewith, a memory controller having an associated controller memory, a processor bus coupled between the processor and the memory controller, and a main memory. The data processing system further includes a lower level cache coupled to the processor bus in parallel with the processor and memory controller. According to a first aspect of the present invention, the memory controller includes logic, which in response to receipt of a write request that will not be serviced by the lower level cache and for which the associated data is not a replaced modified cache line, stores the associated data within the controller memory associated with the memory controller, thereby optimizing data storage within the data processing system. According to a second aspect of the present invention, the memory controller includes logic, which in response to receipt of a request for information residing only in main memory, fetches the requested information from main memory and stores additional information adjacent to said requested data in main memory within a prefetch buffer, thereby minimizing access time to the prefetched information.</p><p>The above as well as additional objects, features, and advantages of the present invention will become apparent in the following detailed written description.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:</p><p>FIG. 1 illustrates a high-level block diagram of a data processing system in accordance with the method and system of the present invention;</p><p>FIG. 2 depicts a more detailed block diagram of a memory controller in accordance with the method and system of the present invention;</p><p>FIG. 3 illustrates a high-level logic flowchart of a preferred embodiment of the method of the present invention;</p><p>FIG. 4 is a high-level logic flowchart of a preferred embodiment of the method utilized by a memory controller which employs the present invention to service an instruction fetch request;</p><p>FIG. 5 is a high-level logic flowchart of a preferred embodiment of the method utilized by a memory controller which employs the present invention to service a data write request; and</p><p>FIG. 6 is a high-level logic flowchart of a preferred embodiment of the method utilized by a memory controller which employs the present invention to service a data read request.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF PREFERRED EMBODIMENT</h4><p>With reference now to the figures and in particular with reference to FIG. 1, there is illustrated a block diagram of a preferred embodiment of a data processing system in accordance with the method and system of the present invention. As will be appreciated by those skilled in the art, many of the details of data processing system 10 that are not relevant to the present invention have been omitted for the purpose of clarity. As illustrated, data processing system 10 includes a central processing unit (CPU) 12 which executes software instructions. While any appropriate microprocessor can be utilized for CPU 12, CPU 12 is preferably one of the PowerPC\u2122 line of microprocessors available from IBM Microelectronics. Alternatively, CPU 12 can be implemented as an Intel Pentium\u2122 or an 80486 microprocessor. To improve data and instruction access times, CPU 12 is equipped with an on-board level one (L1) cache 14. Although in the following description the cache line size of L1 cache 14 is described as being X bytes in length, in a preferred embodiment of the present invention in which the word length of CPU 12 is 8 bytes, the cache line length of L1 cache 14 is 32 bytes. CPU 12 is coupled to processor bus 18, which preferably has a bandwidth of 8 bytes, to facilitate communication of data and instructions between CPU 12, L2 cache 16 and memory controller 20.</p><p>As depicted, L2 cache 16 is coupled to processor bus 18 in parallel with CPU 12 and memory controller 20 in a look-aside cache configuration. Accordingly, read and write requests transmitted by CPU 12 via processor bus 18 are received concurrently by memory controller 20 and L2 cache 16. In response to an L2 cache hit, L2 cache 16 signals memory controller 20 to abort the indicated operation and returns the requested data to CPU 12 in zero wait states. L2 cache 16 preferably has a cache line length of X bytes to avoid the complications inherent in supporting multiple caches having diverse cache line sizes on a shared bus. As illustrated, L2 cache 16 includes an L2 cache controller 17, which controls the operation of L2 cache 16. Thus, L2 cache controller 17 maintains L2 cache coherency by enforcing a selected coherency protocol, determines whether data associated with memory addresses within main memory 22 are cacheable, or capable of residing within L2 cache 16, and performs many other conventional cache management functions.</p><p>Data processing system 10 further includes memory controller 20. Memory controller 20 contains logic circuitry which fetches data and instructions from main memory 22 in response to receipt of read and write requests from CPU 12 which cannot be serviced by L2 cache 16. Thus, memory controller 20 provides a memory interface between CPU 12 and main memory 22. In addition, memory controller 20 includes logic circuitry which provides a system bus interface between system bus 24 and CPU 12 and main memory 22. In a preferred embodiment of the present invention, the system bus interface within memory controller 20 supports memory mapped I/O by transmitting data received from CPU 12 to system bus 24 if the specified address maps to an address assigned to an I/O device.</p><p>As is further illustrated within FIG. 1, data processing system 10 includes read only memory (ROM) 26, I/O adapter 28, secondary storage 30, and display adapter 32, which are each coupled to system bus 24. ROM 26 and secondary storage 30 provide storage for operating system and application programs and data. I/O adapter 28 supports the attachment of input devices, such as a mouse and keyboard, to data processing system 10 to enable a user to input data and instructions. Display adapter 32 enables the attachment of a video display device to output data to a user.</p><p>Referring now to FIG. 2, there is depicted a more detailed pictorial representation of the logical structure of memory controller 20 in accordance with the method and system of the present invention. As illustrated, memory controller 20 contains a conventional read/write buffer 40 and write buffer 42. Read/write buffer 40 is utilized to buffer data transmitted to and received from CPU 12 via processor bus 18. Write buffer 42 is utilized to buffer data to be written to main memory 22. Each of read/write buffer 40 and write buffer 42 preferably has the same length as a cache line of L1 cache 14 in order to support efficient data transfers, for example, burst transfers between memory controller 20 and CPU 12.</p><p>In accordance with the present invention, memory controller 20 further includes an instruction prefetch buffer (IPB) 44 and a data prefetch buffer (DPB) 46. IPB 44 and DPB 46 are utilized by memory controller 20 to prefetch data and instructions for CPU 12. As described above, based upon the principle of locality of reference, it has been shown that cache miss ratios are greatly reduced by implementing a 2:1 L2 to L1 cache line size ratio in order to prefetch an additional L1 cache line of data and instructions during each fetch from memory. Because diverse L2 and L1 cache line sizes are not easily supported when a look-aside cache configuration is utilized, memory controller 20 fetches two cache lines of data or instructions from main memory 22 during particular fetch operations and stores the data or instructions contained within the cache line not immediately requested by CPU 12 within the appropriate one of IPB 44 and DPB 46. Thus, as will be described in greater detail below, memory controller 20 supports the prefetching of data and instructions in conjunction with a look-aside configuration of L2 cache 16.</p><p>According to another aspect of the present invention, memory controller 20 also includes write allocate/read invalidate (WA/RI) cache 48 and its associated cache control and tags 50. Within conventional data processing systems which implement a look-aside L2 cache, the memory controller simply writes data received from the processor to the main memory in response to an L2 cache write miss. Thus, a conventional look-aside cache typically does not allocate a cache line in response to a write miss. This storage management policy is beneficial if the data to be written is a replaced L1 or L2 cache line since the probability that the replaced cache line will soon be accessed again is small. However, if the data write is a stack operation, failure to allocate a cache line in response to a write miss degrades system performance.</p><p>As is well known to those skilled in the art, a stack is a logical first-in/last-out (FILO) queue which is utilized to save parameters during procedure calls and other software operations which save parameters. Stack operations tend to write parameters to a data location first (a \"push\") and thereafter read the data location (a \"pop\"). Since the stack data will typically be read only once, stack data is considered invalid following a pop. According to the present invention, in order to efficiently support push stack operations, WA/RI cache 48 within memory controller 20 allocates a cache line on write misses of L2 cache 16 that are single word (non-burst) writes. WA/RI cache 48 does not allocate a cache line on multiple-word writes (burst writes) since burst writes typically represent replaced cache lines that no longer need to be cached. In addition, WA/RI cache 48 invalidates data following a read hit (a pop).</p><p>Finally, memory controller 20 includes control circuitry 52, which manages the operation of memory controller 20 in accordance with the logical process illustrated within FIGS. 3-6. Upon review of FIGS. 3-6 those skilled in the art will appreciate that many operations depicted in a serial fashion therein may in practice be performed in parallel. With reference first to FIG. 3, there is illustrated a high-level logic flowchart of the operation of memory controller 20 in accordance with the method and system of the present invention. As illustrated, the process begins at block 60 and thereafter proceeds to block 62, which illustrates a determination of whether or not an operation request received from CPU 12 via processor bus 18 is an instruction fetch request. In response to a determination that the operation request is not an instruction fetch request, the process passes to block 64. However, in response to a determination that the operation request is an instruction fetch request, the process proceeds through off-page connector A to on-page connector A of FIG. 4.</p><p>Referring now to FIG. 4, there is depicted a high-level logic block diagram of a preferred embodiment of the process utilized by memory controller 20 to prefetch instructions in accordance with the method and system of the present invention. As illustrated, the process proceeds from on-page connector A to block 70, which depicts a determination of whether or not the instruction fetch request resulted in an L2 cache hit. If L2 cache 16 stores the requested instructions, L2 cache 16 signals memory controller 20 to abort its operation. Therefore, if the instructions associated with a specified memory address are stored within L2 cache 16, the process proceeds from block 70 to block 118 and terminates. However, if a determination is made at block 70 that the instruction fetch request resulted in a L2 cache miss, L2 cache 16 cannot service the instruction fetch request and the process passes to block 72.</p><p>Block 72 depicts a determination of whether or not the instructions specified by the instruction fetch request are stored within WA/RI cache 48. If not, the process passes from block 72 to block 80. However, if a determination is made at block 72 that WA/RI cache 48 stores the requested instructions, the process proceeds from block 72 to blocks 74-78, which illustrate memory controller 20 transmitting the requested instructions to CPU 12 via processor bus 18, writing back the WA/RI cache line containing the requested instructions to main memory 22, and invalidating the WA/RI cache line containing the requested instructions. Thereafter, the process passes to block 118 and terminates. Returning to block 72, if a determination is made that the requested instructions are not stored within WA/RI cache 48, the process passes to block 80, which illustrates a determination of whether or not the requested instructions are stored within DPB 46. Although the operation request issued by CPU 12 is an instruction fetch request, memory controller 20 determines whether DPB 46 stores the requested instructions since computer architectures typically permit information to be accessed as instructions or data in order to support self-modifying code. In response to a determination that the requested instructions are stored within DPB 46, the process passes from block 80 to block 82, which illustrates memory controller 20 transmitting the requested instructions to CPU 12. Next, the process proceeds to blocks 84-86, which illustrate invalidating DPB 46 by setting invalid bit 47 if a full L1 cache line was transmitted to CPU 12. The process then passes to block 118 and terminates.</p><p>Returning to block 80, if a determination is made that the requested instructions are not stored within DPB 46, the process passes to block 88, which depicts a determination of whether or not the requested instructions are stored within IPB 44. In response to a determination that the requested instructions are stored within IPB 44, the process proceeds to block 90, which illustrates memory controller 20 transmitting the requested instructions to CPU 12. Next, the process passes to block 92, which depicts determining whether or not a full L1 cache line of instructions was transmitted to CPU 12. If not, the process simply passes to block 118 and terminates. However, if a full L1 cache line was transmitted, the process proceeds to block 94, which illustrates memory controller 20 invalidating the contents of IPB 44 by setting invalid bit 45. The process then proceeds to block 96, which depicts a determination of whether or not the X bytes (X is the cache line length of L1 cache 14) that follow the requested instructions within main memory 22 are cacheable. If not, the process passes to block 118 and terminates. However, if a determination is made that the next X bytes within main memory 22 are cacheable, the process proceeds to block 98, which illustrates memory controller 20 fetching the X bytes following the requested instructions, storing them within IPB 44, and clearing invalid bit 45. Thereafter, the process passes to block 118 and terminates.</p><p>Returning to block 88, if a determination is made that the requested instructions do not reside within IPB 44, the process passes to block 100, which depicts a determination of whether or not the requested instructions represent a full L1 cache line and whether or not both the addresses containing the requested instructions and the following X bytes of information are both cacheable. If so, the process proceeds to block 102, which depicts fetching two L1 cache line lengths of bytes of information from main memory 22. Then, as illustrated at block 104, memory controller 20 transmits the first X bytes of instructions to CPU 12 and stores the second X bytes within IPB 44. Thus, memory controller 20 effectively prefetches a second L1 cache line of instructions because of the likelihood of a subsequent request for instructions within the second X bytes of information. The process then passes to block 118 and terminates.</p><p>Returning to block 100, if a determination is made that either a full L1 cache line was not requested by CPU 12 or that 2\u00d7 bytes are not cacheable, the process passes to block 106, which illustrates a determination of whether or not the X bytes within main memory 22 which contain the address of the requested instruction(s) are cacheable. If not, the process passes to block 108, which depicts memory controller 20 fetching the requested instruction(s) from main memory 22 and sending the requested instructions to CPU 12. The process then passes to block 118 and terminates. However, if a determination is made at block 106 that X bytes of information containing the requested instructions are cacheable, the process passes to block 110 and 112, which illustrate memory controller 20 fetching the X bytes containing the requested instructions from main memory 22 and transmitting the requested instructions to CPU 12. Next, a determination is made at block 114 whether or not X bytes, which comprise a full L1 cache line, were sent to CPU 12. If so, the process passes to block 118 and terminates. However, if less than a full cache line of instructions was sent to CPU 12, the process passes to block 116, which depicts storing the X fetched bytes of information within IPB 44 and marking them valid by clearing invalid bit 45. Thereafter, the process passes to block 118 and terminates.</p><p>Referring again to FIG. 3, if a determination is made at block 62 that the CPU operation request received by memory controller 20 is not an instruction fetch request, the process passes to block 64, which depicts a determination of whether or not the CPU operation request is a data write request. If so, the process proceeds from block 64 through off-page connector B to FIG. 5, which illustrates a preferred embodiment of the process utilized by memory controller 20 to service data write requests.</p><p>With reference now to FIG. 5, the process utilized by memory controller 20 to service data write requests begins at on-page connector B and thereafter proceeds to block 130, which illustrates a determination of whether or not the data write request will be serviced by L2 cache 16. As described above with reference to the instruction fetch request, L2 cache 16 signals that a copy of the data stored at the specified address resides within L2 cache 16 by transmitting an abort signal to memory controller 20. In response to receipt of the abort signal indicating that the write request will be serviced by L2 cache 16, the process proceeds from block 130 to block 172, where the process terminates. However, in response to a determination that the data write request will not be serviced by L2 cache 16, the process proceeds from block 130 to block 132, which illustrates a determination of whether or not the data associated with the data write request is a cache line cast out of (replaced from) L1 cache 14 or L2 cache 16 or is locked or is otherwise noncacheable. If so, the process proceeds from block 132 to block 134, which depicts memory controller 20 writing the data associated with the data write request to the specified address within main memory 22. Next, as depicted at block 136, memory controller 20 snoops WA/RI cache 48, IPB 44, and DPB 46 and invalidates any data within memory controller 20 corresponding to the specified address. The process then passes to block 172 and terminates. Returning to block 132, if a determination is made that the data associated with the data write request is not a cache line cast out of L1 cache 14 or L2 cache 16 or locked or noncacheable, the process passes to block 138, which depicts determining whether or not DPB 46 stores data corresponding to the specified addresses. If so, the process proceeds from block 138 to block 140, which illustrates merging the data associated with the data write request with the data stored within DPB 46. Next, as illustrated at block 142, the information within DPB 46 is written into WA/RI cache 48. Thereafter, the contents of DPB 46 are invalidated by setting invalid bit 47 and the process passes to block 172, where the process terminates.</p><p>Returning to block 138, if a determination is made that DPB 46 does not contain data associated with the specified address, the process proceeds from block 138 to block 146, which illustrates a determination of whether or not IPB 44 stores information associated with the specified addresses. If so, the process proceeds to blocks 148-152, which like block 140-144, depict memory controller 20 merging the data associated with the data write request with the contents of IPB 44, storing the content of IPB 44 within WA/RI cache 48, and thereafter invalidating IPB 44 by setting invalid bit 45. The process then passes to block 172 and terminates. Returning to block 146, if a determination is made that IPB 44 does not store information associated with a specified address, the process proceeds from block 146 to block 154, which illustrates a determination of whether or not information associated with the specified address is stored within WA/RI cache 48. The determination illustrated at block 154 is preferably made by comparing selected bits within the specified address with address tags stored within cache control and tags 50. If the selected bits within the specified address match one of the address tags stored within cache control and tags 50, indicating that WA/RI cache 48 stores information associated with the specified address, the process passes from block 154 to block 156, which illustrates memory controller 20 updating a WA/RI cache line with the data associated with the data write request. The process then passes to block 172 and terminates.</p><p>Returning to block 154, if a determination is made that the data write request results in a cache miss of WA/RI cache 48, the process proceeds from block 154 to block 158, which illustrates allocating a cache line within WA/RI cache 48 for the data associated with the data write request. Next, as depicted at block 160, memory controller 20 fetches X bytes of data containing the specified address from main memory 22 and stores the fetched data within read/write buffer 40. In addition, memory controller merges the data associated with the data write request with the contents of read/write buffer 40. The process then proceeds to block 162, which illustrates a determination of whether or not the replaced WA/RI cache line has been modified. For example, the determination depicted at block 162 may be made by examining the coherency protocol bit associated with the cache line. If the cache line is marked as dirty, the process proceeds to block 164, which illustrates writing the replaced WA/RI cache line to main memory 22. The process then proceeds from either block 164 or block 162 to block 168, which depicts storing the contents of read/write buffer 40 into the allocated WA/RI cache line. The cache line is then marked as modified (valid) as illustrated at block 170. Thereafter, the process passes to block 172 and terminates.</p><p>Referring again to FIG. 3, if a determination is made at block 64 that the CPU operation request received at memory controller 20 is not a data write request, the process passes to block 66, which depicts a determination of whether or not the CPU operation request is a data read request. If not, the process passes to block 68 and terminates. However, if a determination is made at block 66 that the CPU operation request is a data read request, the process proceeds through off-page connector C to on-page connector C of FIG. 6. Referring now to FIG. 6, there is illustrated a high-level flowchart of a preferred embodiment of the method utilized by the present invention to service a data read request. As illustrated, the process passes from on-page connector C to block 180, which illustrates a determination of whether or not the CPU operation request will be serviced by L2 cache 16. If so, the process simply passes to block 232 and terminates. However, if a determination is made at block 180 that L2 cache 16 will not service the CPU operation request, the process passes to block 182, which illustrates a determination of whether or not data associated with the address specified within the data read request is stored within WA/RI cache 48. If so, the process proceeds from block 182 to blocks 184-190, which depict the read invalidate operation of WA/RI cache 48. Fir