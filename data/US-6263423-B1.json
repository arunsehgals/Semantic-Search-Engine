s of bus <b>780</b> indicate the following number of bytes: 2, 2/MOD, 3, 3/MOD, 4, 5, and 5/MOD. If the instruction is 4-bytes long there cannot be a ModR/M byte; this is inherent in the i486\u2122 instruction set. However, the present invention is in no way limited to any specific CISC instruction set. Those skilled in the art will be able to apply the features of the present invention to align and decode any CISC instruction set.</p><p>The RNID_<b>2</b>OP decoder <b>754</b> has an output bus <b>782</b> that is 6 bits wide. One line indicates whether the instruction is 1 byte long. The second line indicates that the instruction is 1 byte long and includes a ModR/M byte, which should be included in the determination of the length of the instruction. Similarly, the remaining output lines of bus <b>782</b> indicate that there are 2, 2/MOD, 3, and 5/MOD. There are no other possible instruction lengths supported by the i486\u2122 instruction set if the opcode is 2 bytes long.</p><p>Outputs <b>784</b> and <b>786</b> of the two RNID_MOD decoders <b>756</b> and <b>758</b> indicate to the RNID_SUM <b>760</b> the five possible additional lengths that can be specified by the ModR/M byte. Each RNID_MOD decoder has a 5 bit wide output bus. The five possible additional lengths are: 1, 2, 3, 5 and 6-bytes. The ModR/M byte itself is included in the total length determination. Any remaining bytes comprise immediate or displacement data.</p><p>FIG. 8 shows a block diagram of the IDDD <b>326</b>. The IDDD determines the shift amounts for the IMM SHIFTER <b>312</b> and the DISP SHIFTER <b>314</b>. The shift amount is determined by the ModR/M byte of the instruction.</p><p>The i486\u2122 instruction set includes two special instructions, the enter_detect and jump_call_detect instructions. The IDDD therefore has a block called the Immediate Special Detector (ISD) <b>802</b> to handle decoding of these instructions. An input <b>803</b> to the ISD is the first byte of the instruction. Two output lines EN_DET and JMP_CL_DET (<b>820</b> and <b>822</b>, respectively) indicate whether one of the corresponding instructions is detected.</p><p>MOD_DEC decoders <b>804</b> and <b>806</b> are identical and decode the immediate and displacement data. Based on ADD_SZ <b>772</b>, decoder <b>804</b> looks at the ModR/M byte assuming a 1 byte opcode and decoder <b>806</b> looks at the ModR/M byte assuming a 2 byte. The instruction byte inputs to MOD_DEC <b>804</b> and <b>806</b> are <b>805</b> and <b>807</b>, respectively. These decoders determine the displacement position and the immediate data position in the instruction stream. Two seven line outputs <b>824</b> and <b>826</b> indicate at what position the displacement and immediate data starts: the displacement can start at position two or position three; and immediate data can start at position two, three, four, six or seven.</p><p>The MOD_DET lines <b>707</b> and <b>714</b> are also input to the SELECT block <b>812</b>.</p><p>The SELECT block <b>812</b> combines the EN_DET and JMP_CL_DET signals, the MOD_DET and MOD_DEC results, and the ADD_SZ and outputs its results on four buses <b>832</b>-<b>838</b>. A DISPlacement <b>1</b> (DISP_<b>1</b>) bus <b>832</b> outputs the displacement shift results assuming a 1 byte opcode. A DISPlacement <b>2</b> (DISP_<b>2</b>) bus <b>834</b> outputs the displacement shift results assuming a 2 byte opcode. IMMediate <b>1</b> and <b>2</b> (IMM_<b>1</b> and IMM_<b>2</b>) buses <b>836</b> and <b>838</b> output the immediate data shift information assuming a 1 byte and a 2 byte opcode, respectively.</p><p>A last block <b>814</b> labeled MOD_SEL/DLY actually selects the appropriate shift amounts and delays these results a half cycle. The half cycle delay performed by MOD_SEL/DLY <b>816</b> represents the delay <b>316</b> shown in FIG. <b>3</b>. The ESC_DET signal <b>774</b> described above is used by the MOD_SEL/DLY block to perform the shift selection. The results are clocked out of the MOD_SEL/DLY <b>814</b> by the clock signals CLK<b>0</b> and CLK<b>1</b> after a half cycle delay. The immediate data shift control signal and the displacement shift control signal are sent to the DISP SHIFTER and the IMM SHIFTER via a SHIFT_D[<b>3</b>:<b>0</b>] bus <b>840</b> and a SHIFT_I[<b>7</b>:<b>0</b>] bus <b>842</b>, respectively. The number of possible positions within the CISC instruction of the immediate and displacement data define the number of bits required to specify the amount of shift.</p><p>A block diagram of the PREFIX DETECTOR <b>328</b> is shown in FIG. <b>9</b>. The PREFIX DETECTOR <b>328</b> comprises a Prefix_Number decoder (PRFX_NO) <b>902</b>, four Prefix_Detector decoders (PRFX_DECs <b>904</b>-<b>910</b>), and a Prefix_Decoder (PRFX_SEL) <b>912</b>.</p><p>The i486\u2122 instruction set, for example, includes 11 possible prefixes. Four total prefixes can be included per instruction, because there are several invalid prefix combinations. The ordering of the four prefixes is also defined by the instruction set. However, rather than detect only the legitimate prefix permutations, the PREFIX DETECTOR uses the four prefix detectors <b>904</b>-<b>910</b> to decode each of the first 4 bytes of the instruction. The first 4 bytes of the instruction are input to the PREFIX DETECTOR on a bus <b>901</b>. Each detector <b>904</b>-<b>910</b> has an output bus (<b>905</b>, <b>907</b>, <b>909</b> and <b>911</b>, respectively) that is 12 bits wide. The 12 outputs indicate which prefix(es) are present, if any are actually decoded at all. The twelfth prefix is called UNLOCK, which is the functional complement of the i486\u2122 LOCK prefix, and is only available to microcode routines during emulation mode.</p><p>An ALIGN_RUN control signal <b>920</b> may be included to enable/disable the prefix decoder, and can be used to mask-out all of the prefixes. A HOLD_PRFX control signal <b>922</b> is used to latch and hold the prefix information. Generally, for alignment of an instruction if the PREFIX DETECTOR <b>328</b> indicates that there are prefixes present, the control logic must latch the prefix information. The prefix information is then used by the ALIGN SHIFTER <b>310</b> to shift-out the prefixes. In the following cycle, the IAU determines the length of the instruction, aligns it, and passes it to the IDU.</p><p>The PRFX_NO decoder <b>902</b> indicates where and how many prefixes are present by decoding the first 4 bytes of the opcode. A logic diagram of the PRFX_NO decoder <b>902</b> is shown in FIG. <b>10</b>. The PRFX_NO decoder comprises four identical decoders <b>1002</b>-<b>1008</b> and a set of logic gates <b>1010</b>. The four decoders <b>1002</b>-<b>1008</b> each look at one of the first four bytes (<b>1010</b>-<b>1013</b>) and determine if a prefix is present. Since it is possible for a prefix byte to follow an opcode byte, the logic gates <b>1010</b> are used to output a result representing the total number of prefixes before the first opcode byte, because prefixes following an opcode apply only to the next instruction's opcode.</p><p>The total number of prefixes is one if the first byte (position) is a prefix and there is no prefix in the second position. As a further example, a prefix in the fourth position does not matter, unless there are prefixes in the first three positions. A logic HIGH (1) output from the bottom NAND <b>1014</b> gate indicates that there are four prefixes; a HIGH output from the second last NAND gate <b>1015</b> indicates that there are three prefixes, and so on. The four NAND gate outputs are combined to form a PREFIX_NO bus <b>1018</b> to indicate the total number of valid prefixes that precede the first opcode byte, i.e, the shift amount output of the PREFIX DETECTOR <b>328</b>.</p><p>The PRFX_NO decoder <b>902</b> also includes a Prefix_Present (PRFX_P) output bus <b>1020</b> (which is also 4 bits wide). Four PRFX_P output lines <b>1020</b>-<b>1023</b> indicate whether or not there is a prefix in the given position, regardless of what the other positions output. The PRFX_P outputs are tapped directly off the four decoder (<b>1002</b>-<b>1008</b>) outputs.</p><p>The PRFX_NO decoder results (to be discussed in connection with FIG. 10) and the information from the PRFX_DEC detectors <b>904</b>-<b>910</b> are combined by the PRFX_SEL decoder <b>912</b>. The prefix information is combined to form one 13 bit output bus <b>924</b> that indicates whether or not there are prefix signals and which prefixes are present.</p><p>3.0 Instruction Decode Unit Overview</p><p>All instructions are passed from the IAU to an Instruction Decode Unit (IDU), and are directly translated into RISC instructions. All instructions to be executed by the IEU are first processed by the IDU. The IDU determines whether each instruction is an emulated or a basic instruction. If it is emulated, the microcode emulation routine consisting entirely of basic instructions is processed. If the instruction is basic, it is directly translated by hardware into one to four nano-instructions and sent to the IEU. It is these nano-instructions, rather than the original CISC or microcode instructions, that the IEU actually executes.</p><p>The partitioning of instructions has two key benefits: the hardware is kept small because it only needs to support simple operations, and bugs are less troublesome because they are more likely to occur in the complex microcode routines, which can easily be changed.</p><p>The IDU's microcode routine support hardware in conjunction with the present invention has several features which make it unique. Typically, microcode instructions consist of control bits for the various datapaths present in a processor, with little or no encoding. The microcode of the present invention, in contrast, is a comparatively high-level machine language designed to emulate a specific complex instruction set. Whereas typical microcode is routed directly to a processor's function units, the microcode of the present invention is processed by the same decoder logic that is used for the target CISC (e.g., 80\u00d786) instructions. This gives the microcode of the present invention much better code-density than is achieved by typical microcode, and makes the microcode easier to develop due to its similarity with the target CISC instruction set. Furthermore, the present invention provides hardware support for microcode revisions: part or all of the on-chip ROM-based microcode can be replaced with external RAM-based microcode under software control. (See commonly owned, co-pending application titled, \u201cA ROM With RAM Cell and Cyclic Redundancy Check Circuit\u201d, Ser. No. 07/802,816, filed Dec. 6, 1991, Attorney Docket No. SP024; the disclosure of which is incorporated herein by reference.)</p><p>The microcode routine language is designed to be a set of instructions that can be executed by the RISC core to perform the functions required by all of the complex emulated instructions, plus the various control and maintenance functions associated with exception handling. Although emulated instructions are typically less performance sensitive than non-emulated (basic) instructions, and exceptions, (which are handled by microcode routines) occur infrequently, it is still critical to the overall system throughput that both be handled efficiently. This goal is achieved through the use of various forms of hardware support for the microcode routines. The present invention comprises four areas of hardware support for microcode: dispatch logic, mailboxes, a nano-instruction format, and special instructions.</p><p>The microcode dispatch logic controls the efficient transfer of program control from the target CISC instruction stream to a microcode routine and back to the target instruction stream. It is handled with a small amount of hardware, and in a manner that is transparent to the RISC core's Instruction Execution Unit (IEU). (The IEU executes the RISC instructions. The \u201cRISC core\u201d mentioned above is synonymous with the IEU. The details of the IEU are not necessary for one skilled in the art to practice the present invention. The features of the present invention are applicable to RISC processors in general.)</p><p>The mailboxes comprise a system of registers used to transfer information from the instruction decode hardware to microcode routines in a systematic way. This allows the hardware to pass instruction operands and similar data to the microcode routines, saving them the task of extracting this data from the instruction.</p><p>The nano-instruction format describes the information that passes from the IDU to the IEU. This format was chosen to allow it to be efficiently extracted from the source CISC instructions, but still provide adequate information to the IEU for dependency checking and function unit control.</p><p>Finally, the special instructions are a set of additional instructions provided to allow complete control of the RISC hardware and support certain unique emulation tasks in hardware, and are CISC instruction set specific.</p><p>3.1 Microcode Dispatch Logic</p><p>The fist step in dispatching to microcode is to determine the address of the microcode routine. This step has two important requirements: each microcode routine must have a unique starting address, and these addresses must be generated quickly. This is fairly easy to achieve for exception handling routines, since the small number of cases that must be handled allows the hardware to store the addresses as constants and merely select between them. Determining the addresses for emulated instructions is more difficult, however, because there are too many to make storing all the addresses feasible.</p><p>The microcode dispatch logic meets the requirements by basing each instruction's dispatch address directly on its opcode. For example, one-byte opcodes are mapped into the address space from 0H to 1FFFH, requiring that the upper three bits of the 16 bit dispatch address be zeroes. These microcode entry points are spaced 64 bytes apart, which requires the six least-significant bits of each entry point address to be zero. This leaves 7 bits undetermined, and they can be taken directly from seven of the opcode bits. Generating the address in this way requires very little logic, as will become evident to those skilled in the art. For example, a multiplexer alone can be used to select the proper bits from the opcode.</p><p>Once the dispatch address for a microcode routine has been determined, the microcode must be fetched from memory. Typically, microcode resides in on-chip ROM, but this is not necessarily the case. As detailed in the above referenced application Ser. No. 07/802,816, each entry point is associated with a ROM-invalid bit which indicates whether or not the ROM routine is correct. This bit is fetched in parallel with the ROM access, and functions similarly to a conventional cache-hit indicator. If this bit indicates that the ROM entry is valid, the microcode routine will continue to be fetched from ROM and executed normally. If the bit indicates that the ROM is invalid, however, the microcode is fetched from external memory, such as RAM or the like.</p><p>On chip microcode routine addressing is handled by the IDU itself. The IDU generates 16 bit addresses for accesses to the microcode ROM. If the ROM-invalid bit corresponding to the ROM entry being addressed indicates that the microcode is invalid, the address of external microcode residing off-chip in main memory is calculated. A U_Base register holds the upper 16 address bits (called the starting address) of the external microcode residing in main memory. The 16 bit address decoded by the IDU is concatenated with the upper 16 bits in the U_Base register to access the external microcode residing in main memory. If the location of the external microcode residing in main memory is changed, the contents of the U_Base register can be modified to reflect the new main memory location.</p><p>This feature allows microcode updates to be performed by replacing certain routines with alternates in external memory, without forcing all microcode to suffer the reduced performance of external memory accesses. It also makes it possible to remove all ROM from the RISC chip and place the entire microcode in external RAM, to reduce the RISC chip's area requirements or to aid in microcode development.</p><p>The dispatch logic is also responsible for providing a means for the microcode routine to return to the main instruction stream when its task is finished. To handle this, separate Program Counters (PC's) and instruction buffers are maintained. During normal operation, the main PC determines the address of each CISC instruction in external memory. A section of memory containing these instructions is fetched by the IFU and stored in the MBUF.</p><p>When an emulated instruction or exception is detected, the PC value and length of the current instruction are stored in temporary buffers, while the microcode dispatch address is calculated as described above and instructions are fetched from this address into the EBUF. Microcode is executed from the EBUF until a microcode \u201creturn\u201d instruction is detected, at which time the preserved PC value is reloaded, and execution continues from the MBUF. Since the MBUF and all other related registers are preserved during the transfer of control to the microcode routine, the transfer back to the CISC program happens very quickly.</p><p>There are two return instructions used by microcode routines to support the differences between instruction emulation routines and exception handling routines. When the microcode routine is entered for the purpose of handling an exception, it is important that after the routine is finished, the processor should return to the exact state in which it was interrupted. When the microcode routine is entered for the purpose of emulating an instruction, however, the routine wants to return to the instruction following the emulated instruction. Otherwise, the emulation routine will be executed a second time. These two functions are handled by the use of two return instructions: aret and eret. The aret instruction returns the processor to its state when microcode was entered, while the eret instruction causes the main PC to be updated and control to return to the next instruction in the target stream.</p><p>3.2 Mailboxes</p><p>For emulation routines to successfully perform the functions of a complex CISC instruction, it is necessary that the microcode have convenient access to the operands referenced by the emulated instruction. In the present invention, this is performed through the use of four mailbox registers. These registers are unique in their use only, they are defined to be the first four of a set of sixteen temporary registers in the integer register file that are available to microcode. Each emulation routine that requires operands or other information from the original instruction can expect to find these values stored in one or more of the mailbox registers upon entry into the routine. When the IDU detects an emulated instruction, it generates instructions which are used by the IEU to load the registers with the values that microcode expects, before execution of the microcode routine itself begins.</p><p>For example, consider the emulation of the Load Machine Status Word instruction (lmsw), which specifies any one of the general registers as an operand. Assume the specific instruction to be emulated is lmsw ax, which loads a 16 bit status word from the \u201cax\u201d register. The same microcode routine is used regardless of the register actually specified in the instruction, so for this instruction mailbox#<b>0</b> is loaded with the status word before microcode entry. When the IDU detects this instruction, it will generate a mov u0,ax instruction for the IEU to move the status word from the \u201cax\u201d register to the \u201cu0\u201d register, which is defined to be mailbox #<b>0</b>. After this mov instruction is sent to the IEU, the microcode routine will be fetched and sent. Thus, the microcode can be written as if the emulated instruction were lmsw u0, and it will correctly handle all of the possible operands that may be specified in the original CISC instruction.</p><p>3.3 Nano-Instruction Format</p><p>As mentioned above, CISC instructions are decoded by the IDU into nano-instructions, which are processed by the RISC processor core, referred to as the IEU. Nano-instructions are passed from the IDU to the IEU in groups of four, called \u201cbuckets\u201d. A single bucket is shown FIG. <b>11</b>. Each bucket consists of two packets, plus general information pertaining to the entire bucket. Packet #<b>0</b> always contains three nano-instructions which are executed in-order: a LOAD instruction <b>1102</b>, an ALU-type instruction <b>1104</b>, and a STORE instruction <b>1106</b>. Packet #<b>1</b> consists of a single ALU-type instruction <b>1108</b>.</p><p>The IEU can accept buckets from the IDU at a peak rate of one per cycle. The IDU processes basic instructions at a peak rate of two per cycle. Since most basic instructions are translated into a single packet, two basic instructions can usually be placed in one bucket and passed to the IEU together. The primary restriction on this rate is that the basic instructions must match the requirements of a bucket:</p><p>only one of the two basic instructions can reference a memory operand (there is only one load/store operation per bucket), and</p><p>both instructions must consist of a single ALU-type operation (as opposed to one instruction requiring two ALU-type operations).</p><p>If one or both of these restrictions is violated, the bucket is sent to the IEU with nano-instructions corresponding to only one of the basic instructions, and the remaining instruction is sent in a later bucket. These requirements closely mirror the capabilities of the IEU, i.e., an IEU having