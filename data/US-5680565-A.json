signals to be generated, causing still further page table walks.</p><p>At step 232, the MOB examines the stuffed PDE load and compares the load with other memory uOP's to determine if an ordering conflict occurs. An ordering conflict may occur if, for example, a senior store operation accesses the same physical address identified by the PDE load. As noted above, a senior store operation is a memory operation which is at retirement but which has not yet been committed to memory via the DCU. At step 232, the PMH also determines if an access or a dirty bit must be set for the page table memory. Access or dirty bits within PDE and PTE tables must be set if corresponding memory pages are modified or accessed as a result of the parent uOP execution. Such will be described in further detail below.</p><p>If an ordering conflict occurs or if an access or dirty bit must be set, execution proceeds to step 234 where the MOB transmits a signal to the PMH causing the PMH to squash the stuffed PDE load and to abort the page table walk. After the page table walk is aborted, the PMH re-dispatches the parent load, at step 236, with the memory type of the parent uOP set to a non-speculateable designation. Thereafter, the MOB intercepts the re-dispatched parent uOP and, upon detecting the non-speculateable data type of the parent uOP, blocks further execution of the parent uOP until retirement. After retirement, if an access or dirty bit needs to be set, execution proceeds to step 239 where a micro-assist page table walk is performed. Otherwise, execution returns to step 218 of FIG. 4 where a non-speculative page table walk is performed. The details of the micro-assist page table walk are described below with reference to FIG. 6. The determination, at step 237, of whether a micro-assist page table walk needs to be performed, may be made by examining an appropriate status bit set within the parent uOP at the time the access or dirty bit was encountered.</p><p>Continuing with the description of FIG. 5, if at step 232 no ordering conflict is detected and no access or dirty bit must be set, execution proceeds to step 238 where the DCU processes the stuffed PDE load. Under certain circumstances, the DCU may squash the stuffed load. If a stuffed load is squashed, execution proceeds to step 240 where the PMH re-dispatches the squashed stuffed load. A stuffed load is squashed by the DCU if the address of the stuffed load matches the address of another outstanding request in the DCU. The re-dispatch of a squashed stuffed load differs from a re-dispatch of the parent uOP, as set forth in step 236. The re-dispatch of the stuffed load is not deferred until retirement. Rather, the stuffed load is merely re-dispatched as soon as possible to re-attempt the DCU access.</p><p>Following step 240, execution returns to step 232 where the re-dispatched stuffed load is again stored and examined by the MOB for possible ordering conflicts. Assuming that no ordering conflicts occur, that no access or dirty bits must be set, and that the DCU does not again squash the stuffed load, execution proceeds to step 242 where the DCU processes the stuffed load and returns data for the stuffed load to the PMH either from an internal cache line or from external memory. As can be appreciated, if an access to external memory is required to satisfy the PDE load, such may require tens or hundreds of clock cycles to occur. If the PMH includes an internal PDE cache, then the PDE stuffed load may be satisfied without requiring action by the DCU.</p><p>After data is retrieved for one of the stuffed loads, execution proceeds to step 244 where the PMH determines whether the page table walk is complete. If the page table walk is not yet complete, execution returns to step 230 where the PMH dispatches any remaining stuffed loads, such as the PTE load, that is required. In general, the page table walk is a multi-step operation which may require several stuffed loads, resulting in re-execution of steps 230, 232, 238 and 242. The PMH may include a state machine to help facilitate execution of the various steps of the page table walk. The actual sequence of states that the PMH goes through to perform the page table walk and determine the physical address is not pertinent to the present invention and will not be described in detail herein. As noted, the PMH may also include a PDE cache for caching PDE entries to expedite the page table walk. Also, as noted above, since a determination of whether a speculative page table walk may be performed is based upon the speculatability of the PDE and PTE memory, the page table walk is aborted if the such memory is found to be nonospeculateable during execution of the page table walk. If such occurs, execution proceeds to step 226 (FIG. 4) where the page table walk is deferred until the parent uOP is no longer speculative.</p><p>If, at step 244, it is determined that the page table walk is complete, then the PMH determines the physical address corresponding to the linear address of the parent uOP.</p><p>When the page table walk is complete, the physical address corresponding to the linear address of the parent uOP is calculated at step 246. As noted above, the PMH accesses the DTLB or the MTRR's to determine the speculatability of the PDE and PTE memory targeted by the stuffed loads. If the PDE and PTE memory is found to be non-speculateable, appropriate action can be taken, including possible re-execution of the page table walk for the parent uOP after retirement of the parent uOP.</p><p>With reference to FIG. 6, the micro-assist page table walk of step 239 of FIG. 5 will now be described in detail. Access and dirty bits in the page directory entries and in the page table entries are used by operating system (OS) software for executing page replacement algorithms to determine, for example, which page to swap out of physical memory to a disk when a new page is needed and when no unused pages are available in physical memory. An access bit marks a page which has been accessed by, for example, a load or a store. A dirty bit marks a page which has been subject to a store operation. The access and dirty bits facilitate a determination by the OS of whether page swapping is needed. As noted above, access and dirty bits within the PDE and PTE tables should be set in the event that the corresponding pages are accessed or modified. The access and dirty bits need to be set only if the bits are initially clear when a page table walk is executed. In other words, the access and dirty bits need to be set only on the first load or store to the page. Although such bits could be set speculatively during a speculative page table walk, such action could result in the operating system swapping pages into and out of main memory based on the speculative memory access operation that is later squashed. In such a circumstance, pages could be swapped in and out of memory needlessly. Hence, it is desirable to defer execution of a page table walk requiring the setting of access or dirty bits until the parent uOP has retired. In one possible implementation, the execution of the page table walk requiring the setting of the access or dirty bits is simply performed by re-dispatching the parent uOP after retirement and performing a non-speculative page table walk within the PMH as set forth in step 218 of FIG. 4. Although such an implementation is certainly feasible, a preferred embodiment of the invention performs a page table walk which requires the setting of an access or dirty bit using a micro-code assist. In other words, micro-code uOP's are generated which steer the PMH into performing a page table walk, without the page table walk being actually controlled by the PMH. Preferably the PMH is locked during the entire micro-assisted page table walk to prevent execution of any speculative walks at the same time. The access and dirty bits are set using an atomic access involving locked read/modify/write sequences.</p><p>FIG. 6 illustrates a sequence of steps for performing the micro-assist page table walk. At step 248, a micro-code unit (not separately shown) within the out-of-order engine of the microprocessor begins generating a sequence of micro-code uOP's. More specifically, at step 248, a locked PDE load/store pair of uOP's are generated for steering the PMH into initiating a page table walk while setting an access or dirty bit within the PDE. A sequence of steps through which the PDE portion of a page table walk is processed, is illustrated in steps 250-266. After step 266, execution proceeds to 267 where the micro-code generates micro-assist PTE uOP's for steering the PMH to complete the page table walk while setting an access or dirty bit within the PTE. The sequence of steps for performing the actual PTE portion of the page table walk is also illustrated at steps 250-266. Thus, steps 250-266 are executed at least twice to perform the entire page table walk and to separately set, if needed, access and dirty bits within the both the PDE and the PTE.</p><p>Steps 250-266 will now be described. The micro-assist uOP's are allocated by the RS at step 250. Since each micro-assist uOP already includes a linear address, the AGU is bypassed. It should be noted that the micro-assist uOP's are non-speculative uOP's since the micro-assist uOP's are generated based on a parent uOP which has already been retired. At step 252 the RS dispatches the micro-assist uOP's to the memory subsystem wherein the PMH, MOB, DTLB, and DCU latch and process the micro-assist uOP's as if the micro-assist uOP's were normal uOP's. Also, the DTLB responds to the micro-assist uOP's by transmitting a miss signal, if appropriate, to the PMH loading the PMH to respond to the micro-assisted page table walk. Preferably the PMH examines the OPCODE of the micro-assist uOP's to determine whether the page table walk should be a micro-assisted page table walk or a non-micro-assisted page table walk, such as described above. The PMH acts as a physical address generation unit for the micro-assisted PDE and PTE loads.</p><p>The DCU attempts to satisfy the micro-assist uOP's by retrieving the appropriate page directory or page table data. As with any DCU operation, the DCU may squash the micro-assist uOP's, if other pending DCU operations access the same memory location. If the DCU squashes one of the micro-assist loads, at step 254, execution proceeds to step 256 wherein the PMH re-dispatches the squashed micro-assist uOP. Execution returns to step 254 where the DCU again attempts to satisfy the micro-assist uOP. It should be noted that the DCU returns PDE and PTE load data to the RS and ROB as well as the PMH. This is in contrast to the non-micro-assisted page table walk described above, wherein loads are employed in which the RS and ROB do not receive or respond to. The ROB reorders the micro-assisted loads, as it reorders any non-stuffed load.</p><p>If the DCU does not squash the micro-assist uOP, execution proceeds to step 258 where the DCU writes back data for the micro-assist uOP to the PMH and to any other functional components requiring access to the information. Any page fault detected by the DCU is also transmitted to the PMH. In the event that the fault is detected at step 260, execution proceeds to step 262 where the PMH re-dispatches the parent uOP causing the initial DTLB miss, resulting in a non-speculative page table walk as set forth in block 208 of FIG. 4. Within step 262, the micro-code controlling the micro-assisted page table walk may branch into a fault branch for specifically controlling the re-dispatch of the parent uOP. If no fault is detected, the PMH sets the necessary access or dirty bit as appropriate at step 264. The actual setting of the access or dirty bits may also be performed directly by micro-code.</p><p>If the page table walk is not yet complete, execution proceeds from step 266 to step 267 where the micro-code generates the aforementioned PTE micro-assist uOP's. Thereafter, steps 250-266 are re-executed for setting the access or dirty bits within the PTE.</p><p>If the micro-assist page table walk is complete, then execution proceeds from step 266 to step 268 where the PMH determines the physical address of the parent uOP based on data received from the micro-assist PTE and PDE loads. Thereafter execution proceeds at block 220 of FIG. 4. As with a normal page table walk, the micro-assisted page table walk may require that the PMH transition through several states. However, unlike the page table walks described above, the PMH under a micro-assist page table walk does not control the page table walk but merely responds to the micro-assist uOP's dispatched from the RS.</p><p>Thus, FIGS. 1-6 collectively illustrate a method and apparatus for performing page table walks in a microprocessor capable of speculative execution of memory instructions. Numerous implementations of the microprocessor and its internal components may be set forth in accordance with the general principles of the invention. Accordingly, particular details of the structure, function and operation are functional elements such as PMH, DCU, DTLB, RS, MOB and ROB will not be set forth herein. However, as noted above, the invention is preferably implemented within a microprocessor capable of pipelined execution of memory instructions.</p><p>Referring to FIGS. 7-9, pipeline stages for an exemplary system are set forth. The system having the pipeline of FIGS. 7-9 is configured in accordance with the preferred embodiments described above wherein the PMH includes both MTRR's and a PDE cache for expediting the page table walk. FIG. 7 illustrates a page table walk which misses the PDE cache. FIG. 8 illustrates a page table walk which hits the PDE cache. As will be described more fully below, the actual memory pipeline is only three steps long. Hence, arbitration may be required to coordinate access to the memory pipeline. FIG. 8 illustrates a page table walk for the case of a PDE cache hit, wherein the PMH is delayed in gaining access to the memory pipeline.</p><p>Each of FIGS. 7-9 illustrates an overall execution pipeline 300, a page table walk level pipeline 302 as well as the actual states 304 of the PMH. The overall execution pipeline 302 includes stages for an instruction read, an instruction load, a rotate operation and first and second decode operations. Additional pipe stages include a rename/allocate stage, a ROB read/RS ready schedule stage, and dispatch, execute, and first and second retirement stages. Functions performed within overall pipeline 300 are, in general, performed by components of the microprocessor such as the ROB, RS, AGU, etc. and such action will not be described in detail herein.</p><p>The page table walk pipeline 302, actually includes stages from the overall pipeline 302, such as a RS dispatch and an AGU stage, as well as separate memory pipeline stages. In FIGS. 7-9 steps of the page table walk are identified by pipeline stages, such as 32, 33, 41, 42 and 43. Pipe stages 41, 42 and 43 represent the three stages of the memory pipeline. Pipe stages 32 and 33 represent stages of the overall execution pipeline 300.</p><p>As can be appreciated, at each pipe stage, several memory operations may be performed by different memory components. Indeed, the PMH itself is preferably a two-ported PMH capable of performing at least two operations at each step.</p><p>Referring first to FIG. 7, a page table walk which misses the PDE cache will now be described. Initially, at step 306, the RS dispatches a memory load instruction. Next, at step 308, the PMH latches the OPCODE and linear address of the memory load. Steps 306 and 308 correspond to overall execution pipeline stages 32 and 33 respectively.</p><p>At step 310 the DTLB dispatches a miss signal indicating that the linear address of the memory load missed the DTLB caches. As a result of the miss the PMH must perform a page table walk and, in the example shown, the page table walk is a speculative page table walk. At step 312 PMH requests access to the three stage memory pipeline to dispatch a stuffed PDE load. Preferably, the MOB performs arbitration on the memory pipeline, although such arbitration could alternatively be performed by other functional units as well. Step 312 corresponds to memory pipe stage 41. During pipe stage 41, the MTRR range registers of the PMH may also be read to determine the memory type corresponding to the PDE load.</p><p>Assuming that the MOB grants access to the memory pipeline to the PMH, then on the following 41 pipe stage, i.e. three clock cycles later, the PMH dispatches the PDE load. In FIG. 7, the following 41 pipe stage is also denoted by step 312. At step 314, the PMH dispatches the physical address and memory type of the PDE load to the DTLB. Simultaneously, the DTLB bypasses the stuffed PDE load. Step 314 corresponds to memory pipe stage 42. Next, at step 316, the DCU returns the PDE in response to the PDE load. Step 316 corresponds to memory pipeline stage 43.</p><p>At step 318, the PMH again requests access to the memory pipeline to dispatch a stuffed PTE load. Simultaneously, the PMH accesses the MTRR's to determine the memory type for the PTE load. If access is granted, the PMH dispatches the PTE load three clock cycles later. As can be seen, step 318 and step 312 both correspond to memory pipe stage 41 indicating that only one of the two operations can be performed at a given clock cycle. However, the actions of pipe stages 42 and 43 may be performed simultaneously with that of pipe stage 41. In other words, multiple page table walks may be performed substantially concurrently, each being offset by one step.</p><p>Again, assuming that access to the memory pipeline is granted and the PTE load dispatched, the PMH drives the physical address and the memory type for the PTE load to the DTLB at step 320. Simultaneously, the DTLB bypasses the stuffed PTE load. At step 322, the DCU returns the PDE. With the PDE and PTE values now received by the PMH, the physical address can be calculated.</p><p>At step 324, the PMH again accesses the range registers, this time to determine the memory type for the physical address of the memory load. Also, the PMH requests access to the memory pipeline to re-dispatch the memory load that caused the initial page miss. If access is granted, the PMH dispatches the parent uOP three clock cycles later during the next occurrence of step 324. At step 326, the DTLB updates its internal cache lines. Page fault detection may also occur at step 326. Also, at step 326, the DTLB bypasses the physical address of the parent uOP. Ultimately, at step 328, the DCU responds to the original memory load to return load data.</p><p>In the forgoing, the PMH is active only during stages 312-324 and is idle during stages 306-310 and 324-326.</p><p>It should be noted that FIG. 7 illustrates pipe stages, and not a sequence of sequential clock cycles. The actual number of clock cycles required to perform a page table walk may vary greatly depe