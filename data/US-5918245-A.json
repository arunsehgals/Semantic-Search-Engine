sent invention;</p><p>FIG. 9 is a flowchart illustrating a cache fill operation according to the present invention;</p><p>FIG. 10 is a flowchart illustrating the steps taken for a level one cache miss according to the present invention; and</p><p>FIG. 11 is a timing diagram illustrating a L2 set prediction correction during an L1 cache fill.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DESCRIPTION OF THE PREFERRED EMBODIMENT</h4><p>FIG. 3 is a block diagram of an UltraSparc\u2122 (a trademark of Sun Microsystems, Inc.) microprocessor 10, modified to incorporate the present invention. An instruction cache 12 provides instructions to a decode unit 14. The instruction cache can receive its instructions from a prefetch unit 16, which receives instructions from branch unit 18 and provides a virtual address to an instruction TLB (translation look-aside buffer) 20, which then causes the instructions to be fetched from an off-chip cache through a cache control/system interface 22. The instructions from the off-chip cache are provided to a pre-decode unit 24 to provide certain information, such as whether it is a branch instruction, to instruction cache 12.</p><p>Instructions from decode unit 14 are provided to an instruction buffer 26, where they are accessed by dispatch unit 28. Dispatch unit 28 will provide four decoded instructions at a time along a bus 30, each instruction being provided to one of eight functional units 32-46. The dispatch unit will dispatch four such instructions each cycle, subject to checking for data dependencies and availability of the proper functional unit.</p><p>The first three functional units, the load/store unit 32 and the two integer arithmetic logic unit (ALU) units 34 and 36, share a set of integer registers 48. Floating-point registers 50 are shared by floating point (FP) units 38, 40 and 42 and graphical units 44 and 46. Each of the integer and floating point functional unit groups have a corresponding completion unit, 52 and 54, respectively. The microprocessor also includes an on-chip data cache 56 and a data TLB 58. Finally, an optional on-chip second level cache tag memory 55 is shown, according to one embodiment of the invention, as discussed below.</p><p>FIG. 4 is a block diagram of a chipset including processor 10 of FIG. 3. Also shown are L2 cache tags memory 80, and L2 cache data memory 82. In addition, a data buffer 84 for connecting to the system data bus 86 is shown. In the example shown, a 16-bit address bus 88 connects between processor 10 and tag memory 80, with the tag data being provided on a 28-bit tag data bus 89. An 18-bit address bus 90 connects to the L2 data cache 82, with a 144 bit data bus 92 to read or write cache data. As can be seen, duplicating this number of lines for multiple sets of an N-way set-associative L2 cache would dramatically increase the number of pins required. Accordingly, a direct-mapped cache is typically used for such an L2 cache implementation. However, in order to properly support multi-threaded, multi-program applications, a predictive set-associative level two or higher level cache can be used if the present invention is implemented to provide L2 set prediction.</p><p>FIG. 5 is a diagram of the data format for a cache entry using the present invention where the set size is less than or equal to the page size. This format may be used for each cache entry, or for a cache line. Alternately, it can be used separately for the instruction and data caches, or for a unified cache structure. The instruction or data itself is stored in location of field 94, with its corresponding tag stored in a location 96. The LRU (Least Recently Used) information is stored in a location 98, and is used to determine which cache entry should be written over when adding a new cache entry (alternately, the LRU information could be stored once per line, once per set, or in one place for multiple sets). Finally, the set-prediction bits are stored in a location 100. The use of this format allows the elimination of a TLB from the serial accessing path for a physically addressed cache (note that for a virtually addressed cache, no address translation is needed at all). Instead, the set size insures that a sufficient number of bits are present to directly address a cache entry, with the set predictor pointing to the predicted set. The TLB can operate in parallel, with the actual translated address being subsequently compared to the cache tags to determine if the set prediction was correct, and whether there is a cache hit. This format can be used for cache the level-one (L1) cache, or both the level-one and level-two (L2) (or higher level) caches.</p><p>FIG. 6 is a diagram of a cache entry format according to the present invention for both level-one and level-two set-predictions. As in FIG. 5, the instruction/data, tag and LRU bits are included. In addition, a level-one cache set predictor is included in a field 102, and a level-two set predictor is included in a field 104. This format is used for both the data cache and the instruction cache. This format can also be used for a unified cache structure which can store either instructions or data.</p><p>FIG. 7 illustrates a format according to the present invention for separate data and instruction caches. As before, the instruction/data field, tag field and LRU field are used. Instead of a single set predictor for each level, however, two set predictors are used. A level-one set predictor for instructions is provided in a field 106, while a level-one set predictor for data is provided in a field 108. Similarly, a level-two set predictor for instructions is stored in a field 110, while a level-two set predictor for data is stored in a field 112. Since it is not known whether the next fetch will be for an instruction or data, a set predictor for each needs to be stored. Such a unified structure provides certain advantages. For instance, where the fetches alternate between instructions and data, it is not necessary to go back and review the last data entry to predict the set for the next data entry if this information is stored with the instruction. Similarly, the same analysis applies for data. Thus, if the next fetch is an instruction, the instruction predictor is used, while when the next fetch is data, the data set predictor is used. Where separate data and instruction caches are used, the data set predictor could be stored in either the instruction cache or the data cache. If stored in the instruction cache, it can be used if the instruction it is associated with accesses the data cache. The data set predictor (SP) could be sent to the load/store unit of the microprocessor for use in accessing the required data.</p><p>FIG. 8 is a block diagram of one embodiment of a cache of the present invention. In this particular embodiment, a four-way predictive set-associative cache is used, which is not a unified structure. This example was chosen for simplicity, and it is understood that any N value for an N-way predictive set-associative cache may be used, and that a unified structure may be used as discussed earlier. The cache 128 is physically direct-mapped, but logically divided into four sets. Each cache line includes a data portion 114, a tag portion 112, a level-one set predictor 115, and a level-two set predictor 116. LRU information 150 is also included. The data (or instruction) from the cache is provided to the execution unit of the microprocessor on an I/O bus 118. The data is selected by the combination of address bits from address register 132, and the L1 set predictor from the last access in L1 set prediction latch 120. The L1 set predictor for the selected cache entry is then provided to latch 120, to override the previous entry and be ready for the next cache access. At the same time, the level-two set predictor is provided to a latch 126.</p><p>A tag comparator 130 compares the actual input address from register 132 on bus 134 to the tag from the cache. This is used to first determine if the appropriate set was properly predicted. If it was not predicted correctly, a miss signal on line 121 is provided to prefetch unit 122. If the cache entry was an instruction, the instruction already loaded into the instruction buffer is invalidated. Where the cache entry was data, a miss signal is used to invalidate a data register where the cache contents were loaded.</p><p>Comparator 130 then compares the actual input address to the tags for the other logical sets in the cache. This can be done with 3 more accesses (or less, it there is a hit on one of the early comparisons), or multiple comparators could be provided to cut down on the time required for a L1 SP miss. This is physically done at the same time that the cached instruction or data is being output, and is not used if there is a L1 SP hit. If the prediction was a miss, but the data was actually in another logical set in the cache, the correct instruction (or data) is then provided to I/O bus 118. If, however, the data is not in the cache at all, indicating an L1 cache miss, the L2 set predictor from L2 latch 126 is then provided to prefetch unit on line 123 to retrieve the data from the L2 cache.</p><p>In the event of an L2 set-prediction miss, the actual address from register 132 is provided to the L2 cache control logic 22 (see FIG. 3) for comparison to the tags in the L2 cache to determine if the data is indeed resident there. This control logic 22 may be on the same chip as the L1 read circuitry of FIG. 8, or on a separate chip. Because of the limited pins, several accesses may be required to compare to each of the tags in the L2 cache. However, this is a rare occurrence which does not significantly reduce the enhanced performance from using a set-associative cache.</p><p>As can be seen, the use of the L2 set predictor allows the external cache to be accessed directly without comparison to the tags to determine which set should be selected. This avoids the comparison time as well as the bandwidth problem of bringing all the tags and data onto the microprocessor chip for comparison, although the tags subsequently need to be compared to verify a correct hit. In an alternative embodiment, the tags for the L2 cache are stored on the microprocessor chip in a separate memory area. FIG. 3 illustrates a separate memory area 55 for the on-chip L2 cache tags. The L2 cache entries are stored on the external memory chip. This approach can be used as microprocessors are able to integrate more on a single chip, but not enough for the entire L2 cache. Alternately, even if an L2 cache could be completely integrated on the microprocessor chip, this approach allows the L2 cache hit rate to be increased. The set prediction can still be used, with the on-chip tags speeding up the subsequent verification of a hit.</p><p>According to one embodiment of the invention, if the L1 or L2 caches are partitioned so that the set size is less than or equal to the page size, the cache can be accessed in parallel with the TLB translation. For such an implementation) the cache size could be much greater than the page size.</p><p>FIG. 9 is a flowchart for an L1 cache fill operation according to the present invention. In step A, an empty set or the least recently used (LRU) set in the cache is selected. Other mechanisms for selecting a set may be used as well. An empty set is chosen before the cache is filled, and once it is filled, the LRU algorithm or another scheme may be used to select which cache line is to be overwritten.</p><p>Next, the data or instruction and its corresponding tag and other information are written to the address in the selected set (step B). An assumption is made that the next access will be the same set, and this is used to write to the L1 SP field (step C). Alternately, other methods for predicting a next set may be used. If the cache line is being provided from the L2 cache, the set it originated from is used as the L2 set predictor (step D). Alternately, a default value can be used if the data is being retrieved from main memory. Both of these initial set prediction (SP) values are guesses, and are corrected upon a subsequent miss if they are incorrect.</p><p>If there is a misprediction by the set predictor, the set predictor is updated to the correct set. Once the set predictor has been updated, it should always be correct for future accesses as lo