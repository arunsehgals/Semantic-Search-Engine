chitecture is limited to a maximum 32 bit operand size and 32 bit address size. The operand size refers to the number of bits operated upon by the processor (e.g. the number of bits in a source or destination operand). The address size refers to the number of bits in an address generated by the processor. Thus, processors employing the x86 architecture may not serve the needs of applications which may benefit from 64 bit address or operand sizes.</p><p>The x86 architecture can operate using a segmented memory model. When using address sizes of 64 bits, however, a flat memory model may be desirable. The process of generating virtual addresses in a flat memory model can differ from the process of generating virtual addresses in a segmented memory model. Accordingly, for a processor to be able to operate using a flat memory model and a segmented memory model, it must be able to generate virtual addresses for either type of model. It would be desirable for a processor to be able to generate virtual addresses for either a flat memory model or a segmented memory model using existing address generation techniques.</p><h4>SUMMARY OF THE INVENTION</h4><p>The problems outlined above are in large part solved by an apparatus and method for generating virtual addresses for different types of memory models using an existing address generation unit. A processor can be configured to operate using either a segmented memory model or a flat memory model according to an operating mode. When the processor is operating using a segmented memory model, it can use the base address of a segment register to calculate a virtual address. When the processor is operating using a flat memory model, it can use the base address of a pseudo segment register to calculate a virtual address. In one embodiment, this base address can be zero. In this manner, the processor can use existing address generation techniques to generate a virtual address for either a segmented memory model or a flat memory model. More particularly, a segment register and a pseudo segment register can be located in a register file such that a processor can read a value from the register file to perform address generation regardless of the operating mode.</p><p>In one embodiment, a processor can include a segment register that stores a segment descriptor and a pseudo segment register that stores a base address. The segment descriptor includes a base address, a first operating mode indication, and a second operating mode indication. The first and second operating mode indications can be used by the processor along with an enable indication in a control register to establish an operating mode. The operating mode can indicate whether the processor is currently using a segmented memory model or a flat memory model. If the processor is using a segmented memory model, it can convey the base address from the segment register to an address generation unit to generate a virtual address. If the processor is using a flat memory model, it can convey the base address from the pseudo segment register to the address generation unit to generate a virtual address.</p><p>The use of the apparatus and method described herein may advantageously allow a processor to generate virtual addresses for either a segmented memory model or a flat memory model using existing address generation techniques.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>Other objects and advantages of the invention will become apparent upon reading the following detailed description and upon reference to the accompanying drawings in which:</p><p>FIG. 1 is a block diagram of one embodiment of a processor.</p><p>FIG. 2 is a block diagram of one embodiment of a segment descriptor for 32/64 mode.</p><p>FIG. 3 is a block diagram of one embodiment of a segment descriptor for compatibility mode.</p><p>FIG. 4 is a block diagram of operation in compatibility mode and in legacy mode according to one embodiment of the processor shown in FIG. <b>1</b>.</p><p>FIG. 5 is a table illustrating one embodiment of operating modes as a function of segment descriptor and control register values.</p><p>FIG. 6 is a block diagram of one embodiment of a register.</p><p>FIG. 7 is a block diagram of one embodiment of a processor including an address generation unit.</p><p>FIG. 8<i>a </i>is a block diagram of one embodiment of a portion of a segment descriptor table address.</p><p>FIG. 8<i>b </i>is a block diagram of one embodiment of a displacement value.</p><p>FIG. 8<i>c </i>is a block diagram of one embodiment of descriptor tables in a memory.</p><p>FIG. 9 is a flow chart illustrating a method of generating 64 bit addresses.</p><p>FIG. 10 is a flow chart illustrating a method of generating addresses in a 32/64 mode.</p><p>FIG. 11 is a block diagram of one embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><p>FIG. 12 is a block diagram of another embodiment of a computer system including the processor shown in FIG. <b>1</b>.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><p>While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.</p><h4>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS</h4><p>Turning now to FIG. 1, a block diagram illustrating one embodiment of a processor <b>10</b> is shown. Other embodiments are possible and contemplated. In the embodiment of FIG. 1, processor <b>10</b> includes an instruction cache <b>12</b>, an execution core <b>14</b>, a data cache <b>16</b>, an external interface unit <b>18</b>, a memory management unit (MMU) <b>20</b>, and a register file <b>22</b>. In the illustrated embodiment, MMU <b>20</b> includes a set of segment registers <b>24</b>, a first control register <b>26</b>, a second control register <b>28</b>, a local descriptor table register (LDTR) <b>30</b>, and a global descriptor table register (GDTR) <b>32</b>. Instruction cache <b>12</b> is coupled to external interface unit <b>18</b>, execution core <b>14</b>, and MMU <b>20</b>. Execution core <b>14</b> is further coupled to MMU <b>20</b>, register file <b>22</b>, and data cache <b>16</b>. Data cache <b>16</b> is further coupled to MMU <b>20</b> and external interface unit <b>18</b>. External interface unit <b>18</b> is further coupled to MMU <b>20</b> and to an external interface.</p><p>Generally speaking, processor <b>10</b> employs a processor architecture compatible with the x86 architecture and including additional architectural features to support 64 bit processing. Processor <b>10</b> is configured to establish an operating mode in response to information stored in a code segment descriptor corresponding to the currently executing code and further in response to one or more enable indications stored in one or more control registers. As used herein, an \u201coperating mode\u201d specifies default values for various programmably selectable processor attributes. For example, the operating mode may specify a default operand size and a default address size. The default operand size specifies the number of bits in an operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the number of bits in an address of a memory operand of an instruction, unless an instruction's encoding overrides the default. The default address size specifies the size of at least the virtual address of memory operands, and may also specify the size of the physical address. Alternatively, the size of the physical address may be independent of the default address size and may instead be dependent on the LME bit described below (e.g. the physical address may be 32 bits if the LME bit is clear and an implementation-dependent size greater than 32 bits and less than 64 bits if the LME bit is set) or on another control bit (e.g. the physical address extension bit, or PAE bit, in another control register). As used herein, a \u201cvirtual address\u201d is an address generated prior to translation through an address translation mechanism (e.g. a paging mechanism) to a \u201cphysical address\u201d, which is the address actually used to access a memory. Additionally, as used herein, a \u201csegment descriptor\u201d is a data structure created by software and used by the processor to define access control and status for a segment of memory. A \u201csegment descriptor table\u201d is a table in memory having multiple entries, each entry capable of storing a segment descriptor.</p><p>In the illustrated embodiment, MMU <b>20</b> generates an operating mode and conveys the operating mode to execution core <b>14</b>. Execution core <b>14</b> executes instructions using the operating mode. More particularly, execution core <b>14</b> fetches operands having the default operand size from register file <b>22</b> or memory (through data cache <b>16</b>, if the memory operands are cacheable and hit therein, or through external interface unit <b>18</b> if the memory operands are noncacheable or miss data cache <b>16</b>) unless a particular instruction's encoding overrides the default operand size, in which case the overriding operand size is used. Similarly, execution core <b>14</b> generates addresses of memory operands, wherein the addresses have the default address size unless a particular instruction's encoding overrides the default address size, in which case the overriding address size is used. In other embodiments, the information used to generate the operating mode may be shadowed locally in the portions of processor <b>10</b> which use the operating mode (e.g. execution core <b>14</b>), and the operating mode may be determined from the local shadow copies.</p><p>As mentioned above, MMU <b>20</b> generates the operating mode responsive to a code segment descriptor corresponding to the code being executed and further responsive to one or more values in control registers. Information from the code segment descriptor is stored in one of the segment registers <b>24</b> (a register referred to as CS, or code segment). Additionally, control register <b>26</b> stores an enable indication (LME) which is used to enable an operating mode in which the default address size is greater than 32 bits (\u201c32/64 mode\u201d) as well as certain compatibility modes for the 32 bit and 16 bit operating modes. The default operand size may be 32 bits in 32/64 mode, but instructions may override the default 32 bit operand size with a 64 bit operand size when desired. If the LME indication is in an enabled state, then 32/64 mode 