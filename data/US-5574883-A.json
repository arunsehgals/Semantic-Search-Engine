e processor with respect to the memory subsystem), it is desirable to do this as infrequently as possible. Thus, it is useful to implement larger caches as technology allows to further reduce the off-chip traffic.</p><h4>SUMMARY OF THE INVENTION</h4><p>The present invention describes a single chip processor associated with availability of a general cache and a microcode cache memory for holding the most frequently used data and instruction words to make them readily accessible to the processing unit in the chip. Both the general cache unit and the microcode cache unit have a data array section and a tag status LRU array section.</p><p>The processor chip is thus provided with a specialized microcode cache unit to more rapidly supply requested microcode words to the processor.</p><p>Both the general cache and the microcode cache provide a group of \"N\" Tag Status RAMs to hold address information, validity information and parity information on existing data words or microcode words stored in an associated group of \"N\" Data RAMs.</p><p>The processor's address request for a microcode instruction word is fed to the Tag Status RAMs. If a hit is effected by a group of comparators, then the selected data word or microcode word will be found in the Data RAMs and conveyed to a Control Register in one clock cycle for execution.</p><p>If a \"miss\" occurs for a microcode word request, a state machine controller will request the missing word from a control store in main memory.</p><p>A LRU RAM is used to monitor the least recently used set of microcode word addresses so that more recently used words can replace the less recently used words in the Data RAMs.</p><p>The processing unit is provided not only with a general cache, but also with a microcode cache unit for keeping the regularly used microcode words available for use in every clock. The presently described implementation involves a 1024 word general cache and a 2K by 90-bit microcode cache. The cache organization is 4-way set associative and each line is one microcode word wide.</p><p>If the addressed microcode word is available in the microcode cache unit, then it will be loaded into a Control Register at the end of the clock during which the microcode word was requested. The microcode cache is accessed in parallel to the execution of the microcode word residing in the Control Register.</p><p>Should a microcode word be requested that is not available in the microcode cache unit, then all the internal operations of the processor will be \"held\" on the clock after the miss is detected. This allows the execution of the microcode word in the control register to be completed. Once the \"miss\" is detected, a request is made to external system memory to fetch the required microcode word assuming that the interface for doing so is available.</p><p>Any request of a microcode word to the external system will take several clocks to be returned. There is only a limited amount of useful work that can be done by the particular processor unit between a microcode \"miss\" occurring and the missing microword being returned. The function that can be done by hardware during this time is to finish any memory command in execution at the time of the microcode miss, or to service any new invalidate requests by the external system. A LRU or least recently used mechanism is used as a replacement system for the microcode cache when all four lines in a \"set\" of 4 words are valid.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>BRIEF DESCRIPTION OF THE DRAWINGS</h4><p>FIG. 1 is a block diagram of a processor chip utilizing a general cache and microcode cache;</p><p>FIG. 1A is a schematic drawing indicating detailed portions of the elements of FIG. 1; FIG. 1A is composed of three sheets denoted as FIGS. 1AA, 1AB, 1AC;</p><p>FIG. 1B is a schematic detail of the Control Section of FIG. 1; FIG. 1B is composed of two sheets denoted as FIGS. 1BA, 1BB;</p><p>FIG. 1C is a drawing illustrating the arrangement of the General Cache;</p><p>FIG. 1D is a drawing illustrating the configuration of the Microcode Cache;</p><p>FIG. 1E is a more detailed drawing of the General Cache of FIG. 1C; FIG. 1E is composed of two sheets denoted as FIGS. 1EA, 1EB;</p><p>FIG. 2 is a diagram showing the system interface unit;</p><p>FIG. 3 is a diagram illustrating the operational flow from the sequencer;</p><p>FIG. 4 is a block diagram showing the elements of the microcode cache subsystem;</p><p>FIG. 5 is a circuit drawing of the elements of the microcode cache unit shown in two sheets denoted as FIGS. 5A, 5B.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>GENERAL OVERVIEW</h4><p>The environment described herein involves a recently developed processor chip designated as the SCAMP-D which is an acronym for \"Single Chip A-Series Mainframe Processor\". This chip involves a CMOS die which is operative in a 323 pin package to provide a low cost but high-speed processing function. The SCAMP-D processor will allow efficient running of a specialized instruction set used by the Unisys Corporation and designated as the E-mode instruction set. SCAMP-D uses 90-bit instruction words. A control store is utilized which is programmable and thus is capable of disabling the E-mode instruction set in order to run other types of instruction sets. The E Mode instruction set is a specialized set of instructions used in the Unisys Corporation A-Series computer systems.</p><p>The SCAMP-D processor is designed to run at a clock speed of upwards beyond 24 megahertz and the processor requires only one clock signal from the external system. Internal operations of the processor will occur at the speed directly dictated by an external clock. Additionally, the SCAMP-D processor also requires the external system to supply a strobe signal every 512 microseconds.</p><p>Within the SCAMP-D processor, there are five main functional sections which are shown in FIG. 1. These include the data section 30, the control section 20, the microcode cache 10, the general cache 40, and the system interface 50. The system interface 50 connects to the memory subsystem 70 in FIG. 1.</p><p>FIG. 1A shows the main modules of the data section 30 and the interconnections. The data section contains the elements of the data path such as the register file, code isolate, counters, timers, rotating/masking hardware, the arithmetic logic unit and floating point assist hardware. The data section is mainly controlled by the microcode.</p><p>The register file is used to hold the \"state\" of the virtual machine that is implemented through the hardware and microcode combination. This includes addresses defining the E-mode stack, top of stack items and intermediate results. There are 14 register file locations defined to hold up to seven double precision top of stack items of the E-mode stack. This feature helps to reduce the number of transfers to and from main memory during operator execution. The maintenance of these registers is done by a combination of hardware and microcode.</p><p>The register file permits the independent sourcing of two operands to be processed by the data section 30. One operand may be rotated and both may be masked in order to extract fields. After masking, the manipulated operands are sent to the ALU (arithmetic logic unit) where they may be added, subtracted or logically combined. The result may be stored in the register file for use later, or written into the system interface 50 for use as an address, or as data in a memory operation.</p><p>Although the arithmetic logic unit, ALU, only directly supports simple operations like add, subtract, and divide by three, other functions may be performed using multiple passes through the ALU under microcode control or by using a floating point assist hardware.</p><p>The counter/timer block in the data section 30 provides support to the microcode for controlling the number of passes or time of operations. The outputs of the counters and timers are used as inputs to the PMASK allowing them to be selected, tested, and manipulated by microcode.</p><p>The floating point assist (FPA) provides hardware support to the microcode for the E-mode floating point arithmetic operations and integer multiplication. Floating point numeric values in the E-mode system are represented using binary signs/magnitude notation. The hardware support includes a 39-bit multiplier and alignment logic for manipulation of the mantissas and the exponents used to represent floating point numbers.</p><p>Other sources which are fed into the data section 30 involve: a parameter from the code stream, the code pointer value on the program syllable index value from the code isolate, a literal for microcode operand tags, the read data register or the program word address (PWA) within the system interface 50, or the result data being returned from the floating point assist section (FPA) in the data section 30.</p><p>In the data section 30, the Code Isolate contains a two word code buffer where each word is 48 bits. The code buffer contains the OPCODES and the parameters to be executed by the SCAMP-D processor. The Code Isolate is responsible for stepping through the code stream extracting the next OPCODE syllable to be executed and the parameters to be read into the data path. The stepping through the code stream is controlled by a combination of microcode and hardware. The Code Isolate uses the OPCODE which is extracted to generate the operator entry address of the microcode routine responsible for the execution of that operator. It also performs a pre-fetch of the next code word when it has finished using the OPCODES/parameters in one of its code buffers.</p><p>The Code Isolate extracts OPCODES and parameters that are contained within 48-bit code words received from memory. The OPCODES are used to generate Operator Entry addresses into the microcode. Parameters are directed to the P mask for use in the main Data Path. The Code Isolate will indicate to the system interface when new code words are required. The microcode controls the Code Isolate using the Code Isolate control field.</p><p>The Code Isolate manages a 2-code word \"code buffer\" made up of a code buffer -0 and a code buffer -1 each of which is 48-bits wide. As code words become available either from the general cache within the SCAMP-D or from external memory to the SCAMP-D, they are alternately loaded into the code buffer -0 and the code buffer -1.</p><p>Each code buffer is made up of six, 8-bit syllables. The syllables in the code buffer are numbered 0 (most significant byte) to 5 (least significant byte) in code buffer -0 and 6 (most significant byte) to 11 (least significant byte) in code buffer -1.</p><p>The Code Isolate extracts parameter and OPCODE information using a code pointer into the code buffer. The value of the code pointer is stored in a code pointer register. The OPCODE syllables are selected using the new value of the code pointer and parameter syllables are accessed using the current value of code pointer. The current code pointer value is defined to be the value contained in the code pointer register during a clock cycle. The \"new\" code pointer value is defined to be the value that the code pointer will be on the next clock cycle assuming no abort action occurs.</p><p>The new code pointer references which syllable within the code buffer could contain the next operator to be executed. The syllable is loaded into the OPCODE register, OPCODE(7:8) on the next non-aborted clock edge.</p><p>The microcode controls the selection of parameters from the code stream onto the Code Isolate operand bus. This bus can be selected through the P mask as operand data under microcode control. The parameter syllables are always selected relative to the current code pointer value.</p><p>The value of the code pointer can be incremented, either under explicit microcode control or on an E-Mode boundary by a combination of microcode and