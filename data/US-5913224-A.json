As one of ordinary skill in the art will recognize, many different types of information is stored in system memory 300 including real-time code 320 and non-real-time code 350. Processor 101 may fetch code from an internal cache, L2 cache subsystem 200 or system memory 300. As described in greater detail below, however, processor 101 preferably executes real-time code 320 from the L2 cache subsystem, rather than system memory 300, thereby reducing deleterious latency effects on real-time computations.</p><p>Referring now to FIG. 2, the processor 101, L2 cache subsystem 200, and system memory 300 is shown in greater detail. Consistent with the preferred embodiment, the processor 101 includes a CPU core 110 coupled to an internal cache memory subsystem 115 and a local bus interface 140 via local bus 130. Local bus 130 has a predetermined bit width and is the processor's primary bus. Bus interface 140 provides processor 101 with an interface to L2 cache subsystem 200 over lines 160, 161. The CPU core 110 also includes a translation lookaside table (\"TLB\") 150.</p><p>As illustrated, computer system 100 embodies a single processor. It is understood, however, that the present invention may be adapted to multi-processor systems. CPU core 110 is a data processing unit that implements a predetermined instruction set. Exemplary processing units include models 80386, 80486, and Pentium microprocessors. The present invention should not be limited to any particular processing units.</p><p>The TLB 150 generally comprises a cacheable set of table entries 151 to provide translations between virtual addresses and physical addresses, as one of ordinary skill in the art would know. Normally, a page address is derived from the upper order bits of the virtual address and used to access physical page addresses in the TLB. Pages range in size, but 4K bytes is typical. Also, stored in each table entry are various attributes such as read/write bits 152 for indicating whether the data stored at the associated physical address is read-only, write-only, or both. Consistent with the preferred embodiment, the TLB 150 includes with each entry 151 a real-time code bit 153 that specifies whether the information stored at the associated physical page address includes real-time code or not. The real-time code bit 153 is written when the relevant table entry is created by the operating system during commonly known allocation schemes. It is noted that the table entries are only temporarily stored in TLB 150. A table in memory preferably is used to store table entries.</p><p>The TLB real-time lock bit 153 facilitates real-time code to be stored in L2 cache without being overwritten through normal cache replacement behavior. Because cache subsystems typically overwrite their contents based on a least recently used scheme, real-time code executed from cache is at risk for being overwritten before it is completely executed. To avoid overwriting real-time code, the L2 cache is able to lock in specified contents.</p><p>The L2 cache subsystem 200 preferably includes an L2 cache memory 201 coupled to a cache management unit 202 for directing the transfers of data into and out of the L2 cache memory 201. Cache management unit 202 also controls and orchestrates the transfer of data, address and control signals between local bus 130 and system memory 300. Cache management unit 202 preferably includes a memory controller for providing access to L2 cache memory 201. The memory controller may be any one of a number of commonly known memory controllers compatible with the selected CPU core 110 and overall computer architecture. Such a memory controller may be located as part of the processor 101. Processor 101 also includes a real-time lock output signal 161 preferably provided to the cache management unit 202. The real-time lock signal 161 indicates that the information in system memory 300 requested by processor 101 includes real-time code. This feature will be explained in more depth below. L2 cache subsystem 200 also includes a bus interface 235 which provides an interface to system memory 300.</p><p>L2 cache memory 201 includes a plurality of cache lines 220. Associated with each line of L2 cache memory 201 is address tag and state information (not specifically shown). The address tag indicates a physical address in system memory 300 corresponding to each entry within cache memory 201. In this embodiment each entry within L2 cache memory 201 is capable of storing a line of data. A line of data preferably consists of four double words 221 (where each double word comprises 32 bits). It is understood, however, that a line could contain any number of word or double words, depending upon the system. It is further understood that a double word could consist of any number of bits.</p><p>The state information is comprised of a valid bit and a set of dirty bits. A separate dirty bit is allocated for each double word within each line. A valid bit indicates whether a predetermined cache line contains valid cache data, while the dirty bits identify the write status of each double word within each cache line. In an invalid state, there is no valid data in the corresponding cache memory entry. In a valid and clean state, the cache memory entry contains data which is consistent with system memory 300. In a valid and dirty state, the cache memory entry contains valid data which is inconsistent with system memory 300. Typically, the dirty state results when a cache memory entry is altered by a write operation.</p><p>Cache management unit 202 includes an address tag and state logic circuit (not specifically shown) that contains and manages the address tag and state information. A comparator circuit for determining whether a cache hit has occurred, and a snoop write-back circuit that controls the write back of dirty data within L2 cache memory 201. It will be appreciated by those skilled in the art that cache management unit 202 may contain additional conventional circuits to control well-known caching functions such as various read, write, update, invalidate, copy-back, and flush operations. Such circuitry may be implemented using a variety of configurations.</p><p>In one embodiment, L2 cache subsystem 200 comprises a set associative cache configuration. Least recently used replacement may be employed to select one of the ways for replacement.</p><p>System memory 300 is a physical memory device of a predetermined size and may be implemented with DRAM (dynamic random access memory). System memory 300 may be used to store data, code, and the like. The code stored in system memory 300 includes real-time 320. Multiple real-time code modules may be stored in system memory 300.</p><p>Referring still to FIG. 2, cache memory 201 includes a plurality of lines of data 220. Preferably associated with each line of data is a lock bit 230. The lock bit can be set to lock the associated line of data. Once locked, the line of data cannot be overwritten pursuant to normal cache behavior in which the least recently used cache line is overwritten by new data to be stored in the cache. The lock bit overrides the least recently used replacement scheme for the line associated with the lock bit. A \"0\" value for the lock bit indicates that the associated line of data is not locked, where as a lock bit value of \"1\" indicates that the line of data is locked. The logic level of the lock bits, of course, can be reversed, i.e. a \"0\" value indicating the associated line is locked and a \"1\" value indicating that the associated line is not locked. For purposes of the following discussion, it is assumed that a logic \"1\" lock bit value indicates the locked condition. To specify which cache contents to lock, computer system 100 asserts its real-time lock output signal on line 161 to indicate to the cache management unit 202 when to lock data in cache.</p><p>Consistent with the preferred embodiment, generally four major steps facilitate the execution of real-time code from L2 cache. These steps presuppose that the targeted real-time code module has already been written by the operating system into the system memory 300 from a disk or other medium on which the code was stored. First, the processor directs the entire block of real-time code to be stored in the L2 cache memory 201 while indicating to the cache management unit 202 that the information being stored in cache comprises real-time code, as opposed to non-real-time code, data, or other types of information. Second, the L2 cache subsystem 200 locks the real-time code into the L2 cache memory 201 to avoid overwriting. Third, the processor 101 executes the real-time code after it has been stored in L2 cache memory 201. Lastly, after the processor has completed its execution of the real-time code from L2 cache memory and no longer needs access to the code, the L2 cache subsystem unlocks the real-time code freeing up that part of L2 cache memory for other real-time code modules.</p><p>Software to be executed by CPU core 110 normally is transferred from a disk to system memory 300 and then fetched from system memory 300 by CPU core 110 through the L2 cache subsystem 200 and lines 160. Consistent with the preferred embodiment, computer system 100 takes advantage of the L2 cache memory's lock bits, the TLB real-time code bit, and the processor's real-time lock output signal 161 to allow execution of real-time code 320 from L2 cache memory 201, instead of system memory 300.</p><p>Referring now to FIG. 3, a block diagram illustrating the flow of data within computer system 100 to transfer real-time code 320 from system memory 300 to cache memory 201 is shown. Real-time code 320 consists of a plurality of double words, as exemplified by double words \"A\" through \"Z.\" Before the CPU core 110 executes real-time code 320 from L2 cache memory 201, the CPU core 110 must have the real-time code 320 transferred from system memory 300 to L2 cache memory 201. This process preferably is accomplished by a read operation by the CPU code 110 of all of the double words in system memory 300 comprising real-time code 320. Because the real-time code 320 does not already exist in the L2 cache memory 201 when the CPU 110 reads the real-time code 320 for the first time, the cache management unit 202 detects a read miss and directs the real-time code to be transferred into L2 cache memory 201 pursuant to normal L2 cache behavior. A copy of the real-time code thus is placed in L2 cache memory 201 as indicated by the lines of L2 cache memory comprising double words \"A\" through \"Z\".</p><p>These lines of cache containing real-time code ultimately must be locked to prevent replacement. The L2 cache subsystem 200, therefore, must be made aware which of its contents include real-time code and which do not. The processor 101 provides this indication by asserting the real-time lock output signal while reading the code from system memory 300. This signal indicates to the cache management unit 202 that it must lock the lines of cache in which it writes the associated real-time code.</p><p>The following discussion describes how the processor 101 determines that the code it requests for executing is real-time code. As stated, the TLB 150 includes a real-time code bit for each entry. Thus, when the processor initiates a read request and translates the requested virtual address to a physical address by accessing the TLB, the CPU core 110 reads the associated real-time code bit 153. If the bit is set to indicate that the requested information is real-time code, the processor asserts its real-time lock output signal on line 161 while also asserting the address and data signals to effectuate a read cycle.</p><p>Upon detecting a read miss while the processor's real-time lock output signal is asserted, the cache management unit 202 writes the requested real-time code 320 to L2 cache memory 201 and sets the lock bit associated with that line to a logic \"1\" indicating that this line of cache memory cannot be overwritten by subsequent cache replacement activity. Alternatively, the cache management 202 may wait until the entire real-time code 320 is stored in L2 cache memory 201 before setting all of the lock bits to a logic \"1\" level. Once the real-time code is completely stored in L2 cache memory 201 and all of the associated lock bits are set, the CPU core 110 then can execute the real-time code 320. At this point, as one of ordinary skill in the art will readily understand, it is transparent to the CPU core 110 that execution of the real-time code is from L2 cache memory 201 instead of from system memory 300. The CPU core 110 fetches each instruction of the real-time event handler by issuing physical addresses pertaining to locations in system memory 300 of the real-time code 320. The cache management unit 202, however, detects a read hit as the requested instruction of the real-time code is also stored in L2 cache memory 201. In response, the cache management unit 202 directs the requested instruction to be supplied to the CPU core 110 from L2 cache memory 201 instead of from system memory 300. In this manner, the real-time event handler is executed by the CPU core 110 from L2 cache memory 201 with reduced latency and increased latency predictability.</p><p>Once the real-time code 320 is completely executed, it may be desired to unlock the real-time code 320 from L2 cache memory, thus freeing up cache entries for other code or data. Cache lines are unlocked by changing the state of the lock bit associated with the targeted lines. In computer systems consistent with the preferred embodiment, invalidate or flush operations preferably are used to unlock cache entries. Invalidating the cache preferably is initiated upon operating system reallocation of the page corresponding to the real-time code, as one of ordinary skill in the art would understand. For example, when a page is selected for reallocation, if the current translation to the page has the real-time code bit set, the operating system may execute a flush operation to each line in the page. L2 subsystem 200 resets the lock bit for the corresponding line. Alternatively, a flush operation indicated to be a real-time operation via real-time signal 161 may cause all of the lock bits to be reset.</p><p>FIG. 4 shows a flow diagram exemplifying a method consistent with the preferred embodiment for executing real-time code from L2 cache memory. In step 405, the real-time code module to be executed is selected and copied into the system memory by the operating system (step 410). Page allocations and TLB entries in step 415 are updated and if the code copied into system memory is a real-time module, the real-time bit in the corresponding TLB entry is updated. The CPU determines whether the code is real-time or not in step 420 by accessing and checking the state of the real-time code bit corresponding to the real-time code. If the code is real-time, the CPU accesses the entire code in step 435. Upon detecting a read miss in step 440, the L2 cache subsystem writes the real-time code into cache and locks the associated lines. In step 445, the CPU may then execute the real-time code by fetching instructions which are provided by the L2 cache where the code is stored. Finally, in step 450, the lines of cache memory that were used to store the real-time code are unlocked as described above. If however, the code is not real-time (step 420), the CPU fetches the code from memory and executes it according to known protocols.</p><p>It is noted that while the L2 cache in FIGS. 1-3 is interposed between the processor 101 and system memory 300, other cache configurations are possible. For example, the cache may comprise a look aside configuration or backside cache configuration in which a system memory bus couples the CPU, cache, and system memory.</p><p>Referring now to FIG. 5, an alternative embodiment for locking real-time code into cache is shown to comprise L2 cache subsystem 200 coupled to processor 101 over lines 160 and to system memory 300. L2 subsystem 200 includes a processor interface 250, tag logic 255, memory interface 295, data way 0, data way 1, multiplexer 290, comparators 260 and 285, real-time address registers 265, and replacement logic 287. Processor interface 250 couples to tag logic 255, data way 0, and comparators 260, 285 over lines 252. Tag logic255 provides tag information to comparator 260 which compares the address signals provided by processor interface 250 to the tag information provided by tag logic 255 to determine the existence of a cache hit or miss, as one of ordinary skill in the art would know. Comparator 260 provides an output signal on line 262 to multiplexer 290 and another output signal on line 263 to replacement logic 287. The output signal provided to multiplexer 290 is asserted upon detecting a cache hit by comparator 260 to select the requested data from the data way that contains the requested data. The output signal on line 263 indicates the presence of a cache miss to replacement logic 287.</p><p>Memory interface 295 directs the operation of data way 0 and data way 1 via lines 297 dining cache hits and misses and also provides communication with system memory 300 over lines 296 for retrieving data from system memory 300 to be stored in one of the two data ways. Although only two data ways are shown in FIG. 5, one of ordinary skill in the art will recognize that the invention could include additional data ways. The output signals from data way 0 and data way 1 over lines 272, 282, respectively are provided to multiplexer 290. Multiplexer 290 is a known 2:1 multiplexer in which one of two input signals is provided as an output signal in response to the state of a control signal. During a cache miss, multiplexer 290 is controlled by the output signal from comparator 260 on line 262. The signal on line 262 determines which of the two input signals on lines 272 and 282 are to be selected by multiplexer 290 as an output signal on line 292. The output signal of multiplexer 290 is provided to processor interface 250.</p><p>During a cache miss, memory interface 295 is controlled by replacement logic 287 to store data corresponding to the new address (i.e., the address for which there was a cache miss) in one of the data ways. Memory interface 295 retrieves the requested data from system memory over lines 296 and stores the data in one of the two data ways as determined by replacement logic 287 in accordance with the present invention.</p><p>Real time address register 265, although shown as a single register in FIG. 5, may include multiple registers. Each register preferably includes a real-time address field (RTA), a valid bit field (V), and a size field (Sz) associated with a real-time code module. The real-time address field preferably includes the starting address of the real-time code. The size field indicates the size of the real time code whose starting address is specified in the RTA field of register 265. The RTA and Sz fields thus specificy the location of real-time code in system memory. As explained below, by comparing and address from processor 101 to the contents of register 265, comparator 285 can determine whether the address is an address pertaining to real-time code. The V bit indicates whether the real time code locking feature of the present invention associated with the real time code beginning at the RTA address is enabled or disabled. Thus, a V bit that is set indicates that the real-time code locking feature is turned on (enabled) for the real-time code specified by the RTA and Sz fields. Conversely, the real-time code locking feature can be turned off (disabled) by clearing the V bit. The contents of the real-time address register preferably is initiated by the computer's operating system or a device driver as one of ordinary skill will recognize.</p><p>It should be recognized that the contents of register 265 generally define which system memory addresses contain real-time code. Thus, register 265 could be configured differently than that described above. For example, register 265 could include a beginning and an ending address instead of a beginning address and a size value.</p><p>The contents of real-time address register 265 is provided to comparator 285 which compares the contents of the real-time address register 265 to the address provided by processor interface 250. Comparator 285 provides an output signal to replacement logic 287 over lines 288 to indicate whether the address from processor interface 250 is an address corresponding to real-time code, or not. Replacement logic 287 provides control signals to memory interface 295 over lines 294 generally for directing the storage into cache of real-time code in accordance with the present invention.</p><p>The operation of the alternative embodiment shown in FIG. 5 will now be described with reference to four situations--(1) valid bit not set, cache miss, (2) valid bit set, cache miss, and address within the real-time address range specified by register 265, (3) valid bit set, cache miss, and address not within real-time address range specified by register 265, and (4) cache hit. In the second and third situations, it will be seen that data way 1 is used to store real-time code and data way 0 is used to store nonreal-time code. However, the selection of which data way to use for storing real-time code is not important. Thus, data way 0 could be used to store real-time code.</p><p>In the first situation in which a cache miss is detected and the V bits of registers 265 are cleared indicating that the real-time code locking feature of the present invention has been turned off, L2 cache subsystem 200 functions in accordance with known cache protocol. An address provided to processor interface 250 is compared against the tags stored in tag logic 255. Upon detection of cache miss by comparator 260 (i.e., the data corresponding to the address provided by processor interface 250 is not currently stored in either data way), a signal on line 263 directs the replacement logic 287 to store data corresponding to that address in one of the data ways. The V bits from register 265 are also provided to replacement logic 287 on line 266 and thus replacement logic 287 can determine that the locking feature of the invention is disabled. In this situation (cache miss, V bits clear), the replacement logic 287 stores the data corresponding to the address from processor interface 250 in either data way in accordance with known protocols. The data to be stored in cache is retrieved from system memory 300 over lines 296 by memory interface 295 and stored in the selected data way. Replacement logic 287 may use in any commonly known replacement algorithm such as the least recently used algorithm in which the least recently used datum in the data ways is replaced by the new data. Tag logic 255 is then updated by memory interface 295 to include the tag associated with the new data stored in the data ways.</p><p>In the second situation, at least one of the valid bits in registers 265 is set indicating that the real-time locking feature of the present invention is enabled, and a cache miss occurs. A cache miss for a real-time code address results in the storage of the associated real-time code in data way 1. Comparator 260 compares the address to tags from tag logic 255 and indicates the existence of a cache miss on line 263 to replacement logic 287. Comparator 285 consequently compares the address from processor interface 250 to the range of real-time addressed specified by registers 265 and determines that the address from processor interface 250 falls within the range of real-time addresses. Comparator 285 provides a signal on line 288 to replacement logic 287 indicating that the new address pertains to real-time code. In response, replacement logic 287 directs the memory interface 250 to retrieve the real-time code associated with the current address. After retrieval of the real time code, the real-time code is stored in data way 1 without replacing any other real-time code already stored in data way 1. As explained previously, data way 1 is dedicated to the storage of real-time code when a V bit is set. Replacement logic 287 and memory interface 295 cooperate to prevent any real-time code from being replaced when the real-time code locking feature is enabled.</p><p>The third situation is similar to the second situation except that the address received by processor interface 250 is not an address for real-time code. Comparator 260 detects a cache miss and comparator 285 determines that the new address does not lie within the real-time address range specified by registers 265, and that at least one V bit is set indicating that the real-time code feature of the present invention is enabled. Comparator 285 indicates to replacement logic 287 on lines 288 that the address is not a real-time code address. In response, replacement logic 287 directs the memory interface to retrieve the data corresponding to the address from system memory 300 and store it in data way 0 preferably according to the least recently used algorithm described previously.</p><p>In the fourth situation comparator 260 detects a cache hit upon comparing the address from processor interface 250 and tags from tag logic 255. The output signal from comparator 260 on line 262 is 