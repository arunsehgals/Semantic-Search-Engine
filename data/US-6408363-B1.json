 invention, a method of minimizing cache coherency check latency in an out of order instruction execution system having a plurality of processors comprises detecting a request for access to a first data line from a memory hierarchy, the request being made by a first one of the plurality of processors, determining whether the first data line is present in a cache memory associated with a second one of the plurality of processors, calculating an address of at least one additional data line to be pre-flushed from the cache memory to the memory hierarchy, and determining whether a previously made request for the at least one additional data line from the cache memory is pending.</p><?BRFSUM description=\"Brief Summary\" end=\"tail\"?><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"lead\"?><h4>DESCRIPTION OF DRAWINGS</h4><p>Features and advantages of the present invention will become apparent to those skilled in the art from the following description with reference to the drawings, in which:</p><p>FIG. 1 is a block diagram showing the relevant portions of a legacy computer system having an out-of-order instruction execution processor;</p><p>FIG. 2 is a block diagram of an exemplary embodiment of the pre-fetch/pre-flush slot (DPRESLOT) in accordance with the principles of the present invention;</p><p>FIG. 2A is a block diagram of an exemplary embodiment of the cache port arbitration logic in accordance with a preferred embodiment of the present invention;</p><p>FIG. 3 is a flow diagram of an exemplary embodiment of the pre-fetching process in accordance with the principles of the present invention;</p><p>FIG. 4 is a block diagram of an exemplary embodiment of the cache coherency check slot (CCCSLOT) in accordance with the principles of the present invention; and</p><p>FIG. 5 is a flow diagram of an exemplary embodiment of the pre-flushing process in accordance with the principles of the present invention.</p><?brief-description-of-drawings description=\"Brief Description of Drawings\" end=\"tail\"?><?DETDESC description=\"Detailed Description\" end=\"lead\"?><h4>DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</h4><p>For simplicity and illustrative purposes, the principles of the present invention are described by referring mainly to an exemplar embodiment, particularly, with references to an example in which a specific circuit design is implemented. However, one of ordinary skill in the art would readily recognize that the same principles are equally applicable to, and can be implemented in, other circuit designs, and that any such variation would be within such modifications that do not depart from the true spirit and scope of the present invention.</p><p>In accordance with the principles of the present invention, a pre-fetch/pre-flush slot (DPRESLOT) is provided in a memory queue (MQUEUE) of the out-of-order execution processor. The DPRESLOT monitors the transactions between a system interface, e.g., the system bus, and an address reorder buffer slot (ARBSLOT) and/or between the system interface and a cache coherency check slot (CCCSLOT). When a cache miss is detected, the DPRESLOT causes one or more cache lines in addition to the data line, which caused the current cache miss, to be pre-fetched from the memory hierarchy into the cache memory (DCACHE) in anticipation that the additional data would be required in the near future. When a cache write back is detected as a result of a cache coherency check, the DPRESLOT causes one or more cache lines, in addition to the data line currently being written back, to be pre-flushed out to the memory hierarchy from the respective cache memory (DCACHE) of the processor that owns the line, in anticipation that the additional data would be required by the requesting processor in the near future. A logic included in the DPRESLOT prevents a cache miss request for the additional data when another request has already been made for the data. Speculative pre-fetching and pre-flushing of the additional cache lines minimize cache miss latency and coherency check latency of an out of order instruction execution processor.</p><p>In particular, according to a preferred embodiment of the present invention, one or more DPRESLOT(s) is added to the instruction processing mechanism <b>39</b><i>b </i>(FIG. <b>1</b>). In the alternative, one or more of the ARBSLOT shown in FIG. 1 may be modified to perform the functions of the DPRESLOT, which will now be described in more detail.</p><p>FIG. 2 shows a block diagram of an exemplary embodiment of the pre-fetch/pre-flush slot DPRESLOT) <b>200</b> in accordance with the principles of the present invention, which includes a register <b>136</b> for storing a not hit (\u02dcHIT) indicator <b>136</b><i>a </i>set by the signal \u02dcHIT <b>118</b> from the tag compare mechanism <b>108</b> (FIG. <b>1</b>), a cache index <b>136</b><i>b </i>and a real address tag (TAG) <b>136</b><i>c</i>, which are received as an address ADDR <b>128</b> and a TAG <b>134</b>, respectively, from the adjacent address logic <b>213</b>, and, optionally in a preferred embodiment of the present invention, amiss type store <b>136</b><i>d </i>for holding a store flag (STORE) received from a MISS_STORE input <b>214</b>. The single bit flag STORE indicates whether the memory access instruction being processed performs a read or a write operation, and is derived from the instruction currently being processed in the instruction processing mechanism <b>39</b><i>b </i>(FIG. <b>1</b>). The flag STORE is used by the DCACHE <b>24</b> to maintain the cache operation with respect to the pre-fetched data line(s) consistent with the memory access instruction being performed.</p><p>The adjacent address logic <b>213</b> receives the address present on the MISS/COPY_IN ADDR <b>104</b>, which is part of the transactional interface between the instruction processing mechanism <b>39</b><i>b </i>(FIG. 1) and the system interface control <b>102</b> (FIG. <b>1</b>). The adjacent address logic <b>213</b> produces addresses that are adjacently located to the address received from the MISS/COPY_IN ADDR <b>104</b> by, e.g., inverting one or more lower significant bits of the received address or by a use of a counter to generate a number of addresses. In this exemplary embodiment, the least significant bit (LSB) of the received address is inverted to produce a single address having a location immediately next to, i.e., immediately preceding or following, the received address.</p><p>The adjacent address(s) thus produced is output on the ADDR <b>128</b> for storage in the CACHE INDEX <b>136</b><i>b </i>of the register <b>136</b>. The adjacent address logic <b>213</b> also provides the TAG <b>134</b>, which is a real page number (RPN) associated with the adjacent address in the preferred embodiment, for storage in the TAG <b>136</b><i>c </i>of the register <b>136</b>. The register <b>136</b> receives an update signal <b>212</b>. While the update signal <b>212</b> is active, the register <b>136</b> updates its content, i.e., contents of each of the fields, the \u02dcHIT <b>136</b><i>a</i>, the CACHE INDEX <b>136</b><i>b</i>, the TAG <b>136</b><i>c </i>and the STORE <b>136</b><i>d. </i></p><p>The update signal <b>212</b> is output from the inverter <b>219</b>, which receives as its input a BUSY signal <b>204</b> from the busy latch <b>203</b>. The busy latch <b>203</b> may comprise, e.g., a set-and-reset (S-R) flip-flop, and has two inputs, SET <b>205</b> and CLR <b>206</b>, which sets and resets the BUSY signal <b>204</b>, respectively. When the BUSY signal <b>204</b> is set, i.e., active, the update signal <b>212</b> becomes inactive, and thus the updating of the register <b>136</b> is stopped. The SET input <b>205</b> receives a decoded output from the decoder <b>202</b>, which receives input signals, MISS_CAV <b>101</b> and TRANS_TYPE <b>201</b>. The TRANS_TYPE <b>201</b> may be one of but not limited to, a \u201cload miss\u201d resulting from a read instruction, a \u201cstore\u201d miss resulting from a write instruction, and a coherency check response. TRANS_TYPE <b>201</b> is derived from the instruction currently being processed by the instruction processing mechanism <b>39</b><i>b </i>(FIG. 1) and/or from signals received from the system interface control <b>102</b> (FIG. <b>1</b>).</p><p>The decoder <b>202</b> outputs an active SET <b>205</b> signal when the MISS_CAV <b>101</b> indicates a valid address being present on the MISS/COPY_IN ADDR <b>104</b> and when the TRANS_TYPE <b>201</b> indicates that the transaction being processed in the transactional interface between the instruction processing mechanism <b>39</b><i>b </i>(FIG. 1) and the system interface control <b>102</b> (FIG. 1) is a memory access check, which will be described in more detail later.</p><p>The register <b>136</b> continuously updates its content as long as the BUSY signal <b>204</b> remains inactive (i.e., when the update signal <b>212</b> is active). When BUSY signal <b>204</b> becomes active, the register <b>136</b> halts updating its content, and the DPRESLOT <b>200</b> issues an ACCESS_REQ <b>115</b> (shown in FIG. 1) presenting the current contents of the CACHE INDEX <b>136</b><i>b</i>, the TAG <b>136</b><i>c </i>and the STORE <b>136</b><i>d </i>on the ACCESS_ADDR <b>114</b>, the ACCESS TAG_<b>116</b> and the ACCESS_STORE <b>218</b>, respectively, to the DCACHE <b>24</b>.</p><p>In the event that there is a potential hit in the DCACHE <b>24</b>, the status indicator <b>82</b> will reflect a valid cache line(s) as described in more detail in the '178 patent. Further, the tag compare mechanism <b>108</b> reads the tag DCACHE_TAG(s) <b>81</b> and compares it to the tag ACCESS_TAG <b>116</b> associated with the access address ACCESS_ADDR <b>114</b>. When there is a match, the tag compare mechanism <b>108</b> concludes that there is a hit and deasserts the signal \u02dcHIT <b>118</b> to indicate a hit, which causes the CLR input <b>206</b> of the busy latch <b>203</b> to be asserted, causing the BUSY signal <b>204</b> to be deasserted.</p><p>When the cache access misses based upon a status indicator <b>82</b>, or alternatively, when the tag DCACHE_TAG <b>81</b> does not match the tag ACCESS_TAG <b>116</b>, then the tag compare mechanism <b>108</b> asserts the \u02dcHIT signal <b>118</b> to indicate a miss. A compare mechanism <b>145</b> receives a cache index from the address MISS/COPY_IN ADDR <b>104</b>, as indicated by reference arrow <b>146</b>, and compares it to the CACHE INDEX <b>136</b><i>b </i>from the register <b>136</b>, as indicated by reference arrow <b>147</b>. The results of the compare mechanism <b>145</b> are passed to an AND gate <b>214</b>, as indicated by reference arrow <b>149</b>. Provided that the miss control signal MISS_CAV <b>101</b> is asserted, the compare signal <b>149</b> can cause the busy latch <b>203</b> to be reset, causing the BUSY signal <b>204</b> to be deaserted. In this exemplary embodiment, the compare signal <b>149</b> enables the updating of the register <b>136</b> to be resumed after the MISS_GRANTED signal <b>112</b> is received by the DPRESLOT <b>200</b>.</p><p>The busy latch <b>203</b> may also be reset when there is already a pending request for the cache line. If any of the ARBSLOTs <b>148</b> has already requested the same cache line from memory hierarchy (not shown), then the DPRESLOT <b>200</b> will be advised by the status indicator <b>82</b> (FIG. <b>1</b>), as the status indicator <b>82</b> will indicate a miss pending status as described in more detail in the '178 patent. In this case, the tag compare mechanism <b>108</b> asserts the signal HIT_DM <b>121</b> (as shown in FIG. <b>1</b>), which is input, along with a signal ACCESS_+_<b>2</b>, denoted by reference numeral <b>158</b> representing two cycles after the signal ACCESS_REQ <b>115</b> (FIG. <b>3</b>), to the AND logic gate <b>211</b>, which causes the BUSY signal <b>204</b> to be deasserted.</p><p>Yet another occasion in which the busy latch <b>203</b> may be cleared is when a signal indicative of an occurrence of an unexpected catastrophic event is received from the input <b>208</b> of the OR logic gate <b>207</b>. An unexpected catastrophic event may be, e.g., a CPU trap.</p><p>Since the BUSY signal <b>204</b> is input to the AND logic gate <b>137</b>, when it is inactive, i.e., in a deasserted state, the DPRESLOT <b>200</b> is precluded from making a MISS_REQUEST <b>111</b>. The deasserted BUSY signal <b>204</b> also causes the register <b>136</b> to resume update of its contents.</p><p>If, on the other hand, the ACCESS REQ<b>115</b> of this adjacent cache line caused a miss, i.e., \u02dcHIT signal <b>139</b> and the BUSY signal <b>204</b> are asserted, then the AND logic gate <b>137</b> will issue the miss request signal MISS_REQUEST <b>111</b> to the miss arbitrator <b>107</b> (FIG. <b>1</b>). The miss arbitrator <b>107</b> arbitrates by prioritizing the various miss requests that can be generated by the various ARBSLOTS <b>48</b> and/or the DPRESLOT <b>200</b>. Eventually, the miss arbitrator <b>107</b> issues a signal MISS_GRANTED <b>112</b> to grant the miss request. This signal is sent to the driver <b>213</b> in the DPRESLOT <b>200</b>, which in turn asserts the miss control signal MISS_CAV signal <b>101</b> to the system interface control <b>102</b>. The system interface control <b>102</b> in turn makes a memory request to the memory hierarchy (not shown) for the data line based upon the address MISS/COPY_IN ADDR <b>104</b>.</p><p>FIG. 2A shows an exemplary block diagram of the relevant portions of the cache port arbitration logic in accordance with a preferred embodiment of the present invention, in which three drivers <b>220</b> are added, each of which are enabled, i.e., allowed to output the signal presented in the respective inputs, when the CACHE_GRANT signal <b>221</b> is asserted by the cache port arbiter <b>222</b>, which may be a part of the DCACHE <b>24</b>. The CACHE_GRANT signal <b>221</b> is asserted upon a receipt, and an aribitration, of the the CACHE_REQ signal <b>223</b>, which is received from the AND logic gate <b>224</b>. The AND logic gate <b>224</b> in turn receives, as its inputs, the clock pulse <b>225</b>, the BUSY signal <b>204</b>, the \u02dcACCESS+<b>1</b> (i.e., the complement of one clock cycles after the ACCESS_REQ <b>115</b>) <b>226</b> and \u02dcACCESS+<b>2</b> (i.e., the complement of two clock cycles after the ACCESS_REQ <b>115</b>) <b>158</b>.</p><p>The process of the inventive pre-fetch operation will now be described with reference to an exemplary flow diagram shown in FIG. <b>3</b>. In step <b>301</b>, the transactional interface between the instruction processing mechanism <b>39</b><i>b </i>and the system interface control <b>102</b> (which will be referred to as simply the \u201ctransactional interface\u201d hereafter) is continuously monitored for a presence of any transaction, which may be accomplished by, for example, by monitoring for an assertion of the MISS_CAV <b>101</b> in the exemplary DPRESLOT <b>200</b> shown in FIG. <b>2</b>.</p><p>Once a transaction is detected, a determination is made, in step <b>302</b>, whether there is a valid address present in the transactional interface. In the example shown in FIG. 2, the presence of a valid address may be presumed, e.g., when the MISS_CAV signal <b>101</b> is asserted. When it is determined that a valid address is not present on the transactional interface, then the process returns to step <b>301</b>, i.e., the monitoring of the transactional interface continues.</p><p>On the other hand, if a valid address is detected, the process proceeds to step <b>303</b>, during which a determination is made whether the transaction is a memory access request resulting from a cache miss. In the example of FIG. 2, this determination can be made based on the TRANS_TYPE <b>201</b>. When it is determined that the transaction is not a cache miss, then the process returns to step <b>301</b>, i.e., the monitoring of the transactional interface continues.</p><p>However, if the transaction is a memory access request resulting from a cache miss, then, in step <b>304</b>, the monitoring of the transactional interface is halted. In the DPRESLOT <b>200</b>, for example, the updating of the register <b>136</b> is halted by setting the busy latch <b>203</b>. Then, in step <b>305</b>, one or more address(s) of data lines to be pre-fetched are calculated. For example, in the DPRESLOT <b>200</b>, the adjacent address logic <b>213</b> calculates the to-be-pre-fetched addresses by inverting one or more bits (e.g., the least significant bit (LSB)) of the address of the data line, the attempted access of which has caused the cache miss, present on the MISS/COPY_IN ADDR <b>104</b>.</p><p>In step <b>306</b>, a cache look-up operation is performed for the addresses calculated during the above step <b>305</b>. For example, in the example of FIG. 2, the DPRESLOT <b>200</b> issues an ACCESS_REQ <b>115</b> presenting the current contents of the CACHE INDEX <b>136</b><i>b</i>, the TAG <b>136</b><i>c </i>and the STORE <b>136</b><i>d </i>on the ACCESS_ADDR <b>114</b>, the ACCESS_TAG <b>116</b> and the ACCESS_STORE <b>218</b>, respectively, to the DCACHE <b>24</b>.</p><p>In step <b>307</b>, the result of the cache look-up operation is examined to determine whether the to-be-pre-fetched data lines are already present in the cache memory, i.e., a cache hit occurs. For example, in the FIG. 2 example, the DPRESLOT <b>200</b> determines that a cache hit has occurred by observing the \u02dcHIT <b>118</b> being deasserted by the tag compare mechanism <b>108</b>. If a cache hit has occurred, the process returns to step <b>301</b>, and the monitoring of the transactional interface is resumed.</p><p>If, however, in step <b>307</b>, a cache miss is detected, the process proceeds to step <b>308</b>, in which a determination whether a request for the to-be-pre-fetched data line(s) is already made, e.g., by a ARBSLOT <b>48</b> in the example shown in FIG. <b>2</b>. In the example of FIG. 2, a pending request for the data line may be detected from the HIT_DM <b>121</b>. If it is determined that a request for the data line is already pending, then the process returns to step <b>301</b>, and the monitoring of the transactional interface is resumed.</p><p>Finally, in step <b>309</b>, if no prior requests for the data line is pending, a request for the to-be-pre-fetched data line is issued, e.g., by issuing the MISS_REQUEST <b>111</b> in the example of FIG. 2, which eventually leads to MISS_CAV <b>101</b> being asserted, and causes a memory hierarchy access for the data line(s). In a preferred embodiment, once the request for the to-be-pre-fetched data line(s) is issued (MISS_CAV <b>101</b> fires), the process immediately returns to step <b>301</b>, and the entire process is continuously repeated. In FIG. 2, for example, the system interface control <b>102</b> advantageously handles the actual access of the memory hierarchy, allowing the DPRESLOT <b>200</b> to continue the above described process. When the address of the to-be-pre-fetched data line is placed on the MISS/COPY_IN ADDR <b>104</b> as a part of the request to the system control interface <b>102</b>, the compare <b>145</b> receives identical cache index on both of its inputs <b>146</b> and <b>147</b>, and thus the BUSY signal <b>204</b> is deasserted, causing the register <b>136</b> to resume updating of its contents.</p><p>If a miss request is initiated by an instruction in ARBSLOT <b>48</b>, that matches the address on the compare input <b>147</b> before DPRESLOT <b>200</b> receives the MISS_GRANTED signal <b>112</b>, the BUSY signal <b>204</b> will still be deasserted, and updating the register <b>136</b> will still resume.</p><p>The inventive cache pre-flushing system and method in accordance with the principles of the present invention will now be described with references to exemplary embodiments shown in FIGS. 4 and 5.</p><p>According to a preferred embodiment of the present invention, one or more cache coherency check slot (CCCSLOT) is added to the instruction processing mechanism <b>39</b><i>b </i>(FIG. <b>1</b>). In the alternative, one or more of the ARBSLOTs shown in FIG. 1 may be modified to assume the functions of the CCCSLOT, which will now be described in more detail.</p><p>In particular, FIG. 4 shows a block diagram of an exemplary embodiment of the cache coherency check slot (CCCSLOT), which may appear and functions in much similar way as an ARBSLOT <b>48</b>, as described in the '178 patent, with the key differences being, inter alia, the addition of the done latch <b>402</b> and the driver <b>407</b>, and that the address <b>128</b> and the tag <b>134</b> are received, rather than from the address calculator <b>58</b>, from the system interface control <b>102</b>.</p><p>When any of the multiple processors in a multiple processors computing system requests one or more data line(s) from the memory hierarchy, the memory request and the address(s) of the one or more data lines(s) appear on the system interface <b>22</b> (FIG. <b>1</b>). Each processor's system interface <b>102</b>, upon detecting the memory request, issues a CCC_INSERT signal <b>401</b> to its instruction processing mechanism <b>39</b>B.</p><p>To this end, in the preferred embodiment of the present invention, the respective CCCSLOT <b>400</b> of each of the processors receives the ADDR <b>128</b>, the TAG <b>134</b> and the CCC_INSERT signal <b>401</b> from the system interface control <b>102</b>, the ADDR <b>128</b> and the TAG <b>134</b> being associated with the data line being requested by another processor in the system. The CCC_INSERT signal <b>401</b> serves as a clock signal to the register <b>136</b> of the CCCSLOT <b>400</b>, thus allowing the register <b>136</b> to update its CACHE INDEX <b>136</b><i>b </i>and the TAG <b>136</b><i>c </i>with the ADDR <b>128</b> and the TAG <b>134</b>, respectively. The CCC_INSERT signal <b>401</b> is also input to the clear (CLR) input of the done latch <b>402</b>, which may be, e.g., a set-and-reset (S-R) flip-flop. When the CLR input is received, the output of the done latch <b>402</b> becomes inactive. The inverter <b>410</b> inverts the output signal of the done latch <b>401</b>, thus presenting an active signal \u02dcDONE to the input of the AND logic gate <b>137</b> as shown.</p><p>Upon receipt of the CCC_INSERT signal <b>401</b>, the CCCSLOT <b>400</b> issues a ACCESS_REQ signal <b>115</b> to the DCACHE <b>24</b>, and places the CACHE INDEX <b>136</b><i>b </i>and the TAG <b>134</b> on the ACCESS_ADDR <b>114</b> and the ACCESS_TAG <b>116</b>, respectively. In response, the DCACHE <b>24</b> issues the DCACHE TAG(s) <b>81</b> and the STATUS(s) <b>82</b> as shown in FIG. <b>1</b>. In much similar manner as previously described in the '178 patent with regard to the ARBSLOT <b>48</b>, a MISS_REQUEST <b>111</b> is generated when the data line corresponding to the ADDR <b>128</b> and the TAG <b>134</b> is absent from DCACHE <b>24</b>, and when no other request for the same data line is pending. When the MISS_ARBITRATOR <b>107</b> returns the MISS_GRANTED signal <b>112</b> in response to the MISS_REQUEST <b>111</b>, the MISS_GRANTED signal <b>112</b> is input to the SET input of the done latch <b>402</b>, thus producing an active DONE signal to prevent any further MISS-REQUEST <b>111</b> being issued.</p><p>The MISS_GRANTED signal <b>112</b> also enables the driver <b>407</b> to pass the current content of the \u02dcHIT <b>136</b><i>a </i>of the register <b>136</b> onto the CCC_MISS/HIT signal <b>408</b>, which is sent to the system interface control <b>102</b>. Based on the received CCC_MISS/HIT signal <b>408</b> and the STATUS <b>82</b>, the system interface control <b>102</b> determines whether writing back, or flushing, of the data line (i.e., being pointed to by the MISS/COPY_IN ADDR <b>104</b>) from the DCACHE <b>24</b> to the memory hierarchy (not shown) is required. In an embodiment of the present invention, whenever the data line is found in the DCACHE <b>24</b>, i.e., the CCC_MISS/HIT <b>408</b> is inactive, and the STATUS <b>82</b> indicate that the cache line is dirty, the system interface control <b>102</b> causes the data line (i.e., being pointed to by the MISS/COPY_IN ADDR <b>104</b>) to be written out to the processor that requested the cache line.</p><p>When the DPRESLOT <b>200</b> receives the indicated cache coherency check result on the TRANS _TYPE input <b>201</b> driven by the CCCSLOT <b>400</b>, the DPRESLOT <b>200</b> initiates a pre-flushing operation in accordance with the principles of the present invention, which will now be described with references to FIGS. 2 and 5.</p><p>In particular, FIG. 5 shows a flow diagram of an exemplary embodiment of the pre-flushing process, in step <b>501</b> of which, the transactional interface between the instruction processing mechanism <b>39</b><i>b </i>and the system interface control <b>102</b> (which will be referred to as simply the \u201ctransactional interface\u201d hereafter) is continuously monitored for a presence of any transaction, which may be accomplished by, for example, by monitoring for an assertion of the MISS_CAV <b>101</b> in the exemplary DPRESLOT <b>200</b> shown in FIG. <b>2</b>.</p><p>Once a transaction is detected, a determination is made whether there is a valid address present in the transactional interface, e.g., by detecting the MISS_CAV signal <b>101</b> being asserted (step <b>502</b>). When it is determined that a valid address is not present on the transactional interface, then the process returns to step <b>501</b>, i.e., the monitoring of the transactional interface continues.</p><p>On the other hand, if a valid address is detected, the process proceeds to step <b>503</b>, during which a determination is made whether the transaction is a coherency response resulting from a cache coherency check. When it is determined that the transaction is not a cache coherency response, then the process returns to step <b>501</b>, i.e., the monitoring of the transactional interface continues.</p><p>However, if the transaction is a coherency response, e.g., a coherency response transaction requiring the copy of dirty data as indicated by STATUS <b>82</b>, the monitoring of the transactional interface is halted, e.g., by setting the busy latch <b>203</b> to halt the updating of the register <b>136</b>. Then, in step <b>505</b>, one or more address(s) of data lines to be pre-flushed are calculated. The adjacent address logic <b>213</b> calculates the to-be-pre-flushed addresses by inverting one or more bits (e.g., the least significant bit (LSB)) of the address of the data line present on the MISS/COPY_IN ADDR <b>104</b>.</p><p>In step <b>506</b>, a cache look-up operation is performed for the addresses calculated during the above step <b>505</b>. The DPRESLOT <b>200</b> issues an ACCESS_REQ <b>115</b> presenting the current contents of the CACHE INDEX <b>136</b><i>b</i>, the TAG <b>136</b><i>c </i>and the STORE <b>136</b><i>d </i>on the ACCESS_ADDR <b>114</b>, the ACCESS_TAG <b>116</b> and the ACCESS_STORE <b>218</b>, respectively, to the DCACHE <b>24</b>.</p><p>In step <b>507</b>, the result of the cache look-up operation is examined to determine whether the to-be-pre-flushed data line(s) is present in the cache memory; i.e., the DPRESLOT <b>200</b> determines that a cache hit has occurred by observing the \u02dcHIT <b>118</b> being deasserted by the tag compare mechanism <b>108</b>. If a cache miss has occurred, the process returns to step <b>501</b>, and the monitoring of the transactional interface is resumed.</p><p>If, however, in step <b>507</b>, a cache hit is detected, the process proceeds to step <b>508</b>, in which a determination whether a request for the to-be-pre-flushed data line(s) is already made, e.g., by a ARBSLOT <b>48</b> shown in FIG. 1, by observing a HIT_DM <b>121</b>. If it is determined that a request for the data line is already pending, then the process returns to step <b>501</b>, and the monitoring of the transactional interface is resumed.</p><p>Finally, in step <b>509</b>, if no prior requests for the data line is pending, flush transaction for the to-be-pre-flushed data line is issued, e.g., by issuing the MISS_REQUEST <b>111</b>, which causes a memory hierarchy access by the system interface control <b>102</b> to write the data line(s) from DCACHE <b>24</b> to the memory hierarchy. To this end, the \u02dcHIT input to the AND logic gate <b>137</b> may be inverted for the purpose of using the DPRESLOT <b>200</b> for a pre-flushing operation, e.g., when the TRANS_TYPE <b>201</b> indicates a cache coherency check. In a preferred embodiment of the present invention, the STATUS <b>82</b> is consulted, and the to-be-pre-flushed data line is flushed only if the status of the to-be-pre-flushed data line indicates that the data is dirty. In the alternative, the to-be-pre-flushed data line may be flushed without regard to its status. In a preferred embodiment, once the request for the to-be-pre-flushed data line(s) is issued, the process immediately returns to step <b>501</b>, and the entire process is continuously repeated.</p><p>As can be appreciated, an efficient system for pre-fetching and/or pre-flushing one or more data lines, which does not affect the other components of, and thus can be easily integrated into, an o